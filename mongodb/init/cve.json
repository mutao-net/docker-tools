[
    {
        "Modified": "2021-09-29T23:15:00",
        "Published": "2021-09-29T23:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2020-20781",
        "impact": {},
        "last-modified": "2021-09-29T23:15:00",
        "references": [
            "https://github.com/forget-code/ucms/issues/1"
        ],
        "summary": "A stored cross-site scripting (XSS) vulnerability in /ucms/index.php?do=list_edit of UCMS 1.4.7 allows attackers to execute arbitrary web scripts or HTML via a crafted payload in the title, key words, description or content text fields.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T23:15:00",
        "Published": "2021-09-29T23:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-41821",
        "impact": {},
        "last-modified": "2021-09-29T23:15:00",
        "references": [
            "https://github.com/wazuh/wazuh/issues/9201",
            "https://documentation.wazuh.com/current/release-notes/release_4_2_0.html"
        ],
        "summary": "Wazuh Manager in Wazuh through 4.1.5 is affected by a remote Integer Underflow vulnerability that might lead to denial of service. A crafted message must be sent from an authenticated agent to the manager.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T22:15:00",
        "Published": "2021-09-29T22:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2020-20128",
        "impact": {},
        "last-modified": "2021-09-29T22:15:00",
        "references": [
            "https://github.com/wanglelecc/laracms/issues/33"
        ],
        "summary": "LaraCMS v1.0.1 transmits sensitive information in cleartext which can be intercepted by attackers.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T22:15:00",
        "Published": "2021-09-29T22:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2020-20129",
        "impact": {},
        "last-modified": "2021-09-29T22:15:00",
        "references": [
            "https://github.com/wanglelecc/laracms/issues/34"
        ],
        "summary": "LaraCMS v1.0.1 contains a stored cross-site scripting (XSS) vulnerability which allows attackers to execute arbitrary web scripts or HTML via a crafted payload in the content editor.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T22:15:00",
        "Published": "2021-09-29T22:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2020-20131",
        "impact": {},
        "last-modified": "2021-09-29T22:15:00",
        "references": [
            "https://github.com/wanglelecc/laracms/issues/36"
        ],
        "summary": "LaraCMS v1.0.1 contains a stored cross-site scripting (XSS) vulnerability which allows atackers to execute arbitrary web scripts or HTML via a crafted payload in the page management module.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T22:15:00",
        "Published": "2021-09-29T22:15:00",
        "access": {},
        "assigner": "security@eclipse.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-41034",
        "impact": {},
        "last-modified": "2021-09-29T22:15:00",
        "references": [
            "https://bugs.eclipse.org/bugs/show_bug.cgi?id=540989"
        ],
        "summary": "The build of some language stacks of Eclipse Che version 6 includes pulling some binaries from an unsecured HTTP endpoint. As a consequence the builds of such stacks are vulnerable to MITM attacks that allow the replacement of the original binaries with arbitrary ones. The stacks involved are Java 8 (alpine and centos), Android and PHP. The vulnerability is not exploitable at runtime but only when building Che.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T21:40:00",
        "Published": "2021-09-23T13:15:00",
        "access": {
            "authentication": "NONE",
            "complexity": "MEDIUM",
            "vector": "NETWORK"
        },
        "assigner": "cve-assignments@hackerone.com",
        "capec": [
            {
                "id": "62",
                "name": "Cross Site Request Forgery",
                "prerequisites": "",
                "related_weakness": [
                    "306",
                    "352",
                    "664",
                    "716",
                    "732"
                ],
                "solutions": "Use cryptographic tokens to associate a request with a specific action. The token can be regenerated at every request so that if a request with an invalid token is encountered, it can be reliably discarded. The token is considered invalid if it arrived with a request other than the action it was supposed to be associated with. Although less reliable, the use of the optional HTTP Referrer header can also be used to determine whether an incoming request was actually one that the user is authorized for, in the current context. Additionally, the user can also be prompted to confirm an action every time an action concerning potentially sensitive data is invoked. This way, even if the attacker manages to get the user to click on a malicious link and request the desired action, the user has a chance to recover by denying confirmation. This solution is also implicitly tied to using a second factor of authentication before performing such actions. In general, every request must be checked for the appropriate authentication token as well as authorization in the current session context.",
                "summary": "An attacker crafts malicious web links and distributes them (via web pages, email, etc.), typically in a targeted manner, hoping to induce users to click on the link and execute the malicious action against some third-party application. If successful, the action embedded in the malicious link will be processed and accepted by the targeted application with the users' privilege level. This type of attack leverages the persistence and implicit trust placed in user session cookies by many web applications today. In such an architecture, once the user authenticates to an application and a session cookie is created on the user's system, all following transactions for that session are authenticated using that cookie including potential actions initiated by an attacker and simply \"riding\" the existing session cookie."
            },
            {
                "id": "467",
                "name": "Cross Site Identification",
                "prerequisites": "The victim has an active session with the social networking site.",
                "related_weakness": [
                    "352",
                    "359"
                ],
                "solutions": "Usage: Users should not open other tabs in the browser when using a social networking site.",
                "summary": "An attacker harvests identifying information about a victim via an active session that the victim's browser has with a social networking site. A victim may have the social networking site open in one tab or perhaps is simply using the \"remember me\" feature to keep his or her session with the social networking site active. An attacker induces a payload to execute in the victim's browser that transparently to the victim initiates a request to the social networking site (e.g., via available social network site APIs) to retrieve identifying information about a victim. While some of this information may be public, the attacker is able to harvest this information in context and may use it for further attacks on the user (e.g., spear phishing). In one example of an attack, an attacker may post a malicious posting that contains an image with an embedded link. The link actually requests identifying information from the social networking site. A victim who views the malicious posting in his or her browser will have sent identifying information to the attacker, as long as the victim had an active session with the social networking site. There are many other ways in which the attacker may get the payload to execute in the victim's browser mainly by finding a way to hide it in some reputable site that the victim visits. The attacker could also send the link to the victim in an e-mail and trick the victim into clicking on the link. This attack is basically a cross site request forgery attack with two main differences. First, there is no action that is performed on behalf of the user aside from harvesting information. So standard CSRF protection may not work in this situation. Second, what is important in this attack pattern is the nature of the data being harvested, which is identifying information that can be obtained and used in context. This real time harvesting of identifying information can be used as a prelude for launching real time targeted social engineering attacks on the victim."
            },
            {
                "id": "111",
                "name": "JSON Hijacking (aka JavaScript Hijacking)",
                "prerequisites": "JSON is used as a transport mechanism between the client and the server The target server cannot differentiate real requests from forged requests The JSON object returned from the server can be accessed by the attackers' malicious code via a script tag",
                "related_weakness": [
                    "345",
                    "346",
                    "352"
                ],
                "solutions": "Ensure that server side code can differentiate between legitimate requests and forged requests. The solution is similar to protection against Cross Site Request Forger (CSRF), which is to use a hard to guess random nonce (that is unique to the victim's session with the server) that the attacker has no way of knowing (at least in the absence of other weaknesses). Each request from the client to the server should contain this nonce and the server should reject all requests that do not contain the nonce. On the client side, the system's design could make it difficult to get access to the JSON object content via the script tag. Since the JSON object is never assigned locally to a variable, it cannot be readily modified by the attacker before being used by a script tag. For instance, if while(1) was added to the beginning of the JavaScript returned by the server, trying to access it with a script tag would result in an infinite loop. On the other hand, legitimate client side code can remove the while(1) statement after which the JavaScript can be evaluated. A similar result can be achieved by surrounding the returned JavaScript with comment tags, or using other similar techniques (e.g. wrapping the JavaScript with HTML tags). Make the URLs in the system used to retrieve JSON objects unpredictable and unique for each user session. Ensure that to the extent possible, no sensitive data is passed from the server to the client via JSON objects. JavaScript was never intended to play that role, hence the same origin policy does not adequate address this scenario.",
                "summary": "An attacker targets a system that uses JavaScript Object Notation (JSON) as a transport mechanism between the client and the server (common in Web 2.0 systems using AJAX) to steal possibly confidential information transmitted from the server back to the client inside the JSON object by taking advantage of the loophole in the browser's Same Origin Policy that does not prohibit JavaScript from one website to be included and executed in the context of another website. An attacker gets the victim to visit his or her malicious page that contains a script tag whose source points to the vulnerable system with a URL that requests a response from the server containing a JSON object with possibly confidential information. The malicious page also contains malicious code to capture the JSON object returned by the server before any other processing on it can take place, typically by overriding the JavaScript function used to create new objects. This hook allows the malicious code to get access to the creation of each object and transmit the possibly sensitive contents of the captured JSON object to the attackers' server. There is nothing in the browser's security model to prevent the attackers' malicious JavaScript code (originating from attacker's domain) to set up an environment (as described above) to intercept a JSON object response (coming from the vulnerable target system's domain), read its contents and transmit to the attackers' controlled site. The same origin policy protects the domain object model (DOM), but not the JSON."
            },
            {
                "id": "462",
                "name": "Cross-Domain Search Timing",
                "prerequisites": "Ability to issue GET / POST requests cross domainJava Script is enabled in the victim's browserThe victim has an active session with the site from which the attacker would like to receive informationThe victim's site does not protect search functionality with cross site request forgery (CSRF) protection",
                "related_weakness": [
                    "208",
                    "352",
                    "385"
                ],
                "solutions": "Design: The browser's security model could be fixed to not leak timing information for cross domain requests",
                "summary": "An attacker initiates cross domain HTTP / GET requests and times the server responses. The timing of these responses may leak important information on what is happening on the server. Browser's same origin policy prevents the attacker from directly reading the server responses (in the absence of any other weaknesses), but does not prevent the attacker from timing the responses to requests that the attacker issued cross domain. For GET requests an attacker could for instance leverage the \"img\" tag in conjunction with \"onload() / onerror()\" javascript events. For the POST requests, an attacker could leverage the \"iframe\" element and leverage the \"onload()\" event. There is nothing in the current browser security model that prevents an attacker to use these methods to time responses to the attackers' cross domain requests. The timing for these responses leaks information. For instance, if a victim has an active session with their online e-mail account, an attacker could issue search requests in the victim's mailbox. While the attacker is not able to view the responses, based on the timings of the responses, the attacker could ask yes / no questions as to the content of victim's e-mails, who the victim e-mailed, when, etc. This is but one example; There are other scenarios where an attacker could infer potentially sensitive information from cross domain requests by timing the responses while asking the right questions that leak information."
            }
        ],
        "cvss": 5.8,
        "cvss-time": "2021-09-29T21:40:00",
        "cvss-vector": "AV:N/AC:M/Au:N/C:N/I:P/A:P",
        "cwe": "CWE-352",
        "id": "CVE-2021-22953",
        "impact": {
            "availability": "PARTIAL",
            "confidentiality": "NONE",
            "integrity": "PARTIAL"
        },
        "last-modified": "2021-09-29T21:40:00",
        "references": [
            "https://hackerone.com/reports/1102225",
            "https://documentation.concretecms.org/developers/introduction/version-history/856-release-notes"
        ],
        "summary": "A CSRF in Concrete CMS version 8.5.5 and below allows an attacker to clone topics which can lead to UI inconvenience, and exhaustion of disk space.Credit for discovery: \"Solar Security Research Team\"",
        "vulnerable_configuration": [
            "cpe:2.3:a:concretecms:concrete_cms:5.4.1.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.4.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.4.2.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.4.2.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.1.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.1.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.2.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.3.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.3.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.3.4:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.3.5:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.4.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.0.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.0.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.0.4:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.2.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.3.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.4:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.4.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.4.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.4:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.5:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.6:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.7:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.8:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.9:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.10:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.11:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.12:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.13:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.8.1.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.8.2.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.0.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.0.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.0.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.1.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.2.0:-:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.2.0:rc2:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.2.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.3.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.3.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.3.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.0:-:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.0:rc3:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.0:rc4:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.4:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.5:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.5.0:-:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.5.0:rc1:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.5.0:rc2:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.5.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.5.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.5.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.5.4:*:*:*:*:*:*:*"
        ],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": [
            "cpe:2.3:a:concretecms:concrete_cms:5.4.1.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.4.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.4.2.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.4.2.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.1.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.1.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.2.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.3.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.3.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.3.4:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.3.5:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.6.4.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.0.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.0.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.0.4:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.2.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.3.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.4:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.4.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.4.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.4:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.5:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.6:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.7:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.8:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.9:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.10:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.11:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.12:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.7.5.13:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.8.1.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:5.8.2.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.0.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.0.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.0.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.1.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.2.0:-:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.2.0:rc2:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.2.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.3.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.3.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.3.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.0:-:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.0:rc3:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.0:rc4:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.4:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.4.5:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.5.0:-:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.5.0:rc1:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.5.0:rc2:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.5.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.5.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.5.3:*:*:*:*:*:*:*",
            "cpe:2.3:a:concretecms:concrete_cms:8.5.4:*:*:*:*:*:*:*"
        ]
    },
    {
        "Modified": "2021-09-29T21:35:00",
        "Published": "2021-09-24T03:15:00",
        "access": {
            "authentication": "NONE",
            "complexity": "LOW",
            "vector": "NETWORK"
        },
        "assigner": "cve@mitre.org",
        "capec": [
            {
                "id": "105",
                "name": "HTTP Request Splitting",
                "prerequisites": "User-manipulateable HTTP Request headers are processed by the web server",
                "related_weakness": [
                    "436",
                    "444"
                ],
                "solutions": "Make sure to install the latest vendor security patches available for the web server. If possible, make use of SSL. Install a web application firewall that has been secured against HTTP Request Splitting Use web servers that employ a tight HTTP parsing process",
                "summary": "HTTP Request Splitting (also known as HTTP Request Smuggling) is an attack pattern where an attacker attempts to insert additional HTTP requests in the body of the original (enveloping) HTTP request in such a way that the browser interprets it as one request but the web server interprets it as two. There are several ways to perform HTTP request splitting attacks. One way is to include double Content-Length headers in the request to exploit the fact that the devices parsing the request may each use a different header. Another way is to submit an HTTP request with a \"Transfer Encoding: chunked\" in the request header set with setRequestHeader to allow a payload in the HTTP Request that can be considered as another HTTP Request by a subsequent parsing entity. A third way is to use the \"Double CR in an HTTP header\" technique. There are also a few less general techniques targeting specific parsing vulnerabilities in certain web servers."
            },
            {
                "id": "33",
                "name": "HTTP Request Smuggling",
                "prerequisites": "An additional HTTP entity such as an application firewall or a web caching proxy between the attacker and the second entity such as a web server Differences in the way the two HTTP entities parse HTTP requests",
                "related_weakness": [
                    "436",
                    "444",
                    "707"
                ],
                "solutions": "HTTP Request Smuggling is usually targeted at web servers. Therefore, in such cases, careful analysis of the entities must occur during system design prior to deployment. If there are known differences in the way the entities parse HTTP requests, the choice of entities needs consideration. Employing an application firewall can help. However, there are instances of the firewalls being susceptible to HTTP Request Smuggling as well.",
                "summary": "HTTP Request Smuggling results from the discrepancies in parsing HTTP requests between HTTP entities such as web caching proxies or application firewalls. Entities such as web servers, web caching proxies, application firewalls or simple proxies often parse HTTP requests in slightly different ways. Under specific situations where there are two or more such entities in the path of the HTTP request, a specially crafted request is seen by two attacked entities as two different sets of requests. This allows certain requests to be smuggled through to a second entity without the first one realizing it."
            }
        ],
        "cvss": 5.0,
        "cvss-time": "2021-09-29T21:35:00",
        "cvss-vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
        "cwe": "CWE-444",
        "id": "CVE-2021-31923",
        "impact": {
            "availability": "NONE",
            "confidentiality": "NONE",
            "integrity": "PARTIAL"
        },
        "last-modified": "2021-09-29T21:35:00",
        "references": [
            "https://docs.pingidentity.com/bundle/pingaccess-53/page/wco1629833104567.html"
        ],
        "summary": "Ping Identity PingAccess before 5.3.3 allows HTTP request smuggling via header manipulation.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T21:35:00",
        "Published": "2021-09-24T03:15:00",
        "access": {
            "authentication": "NONE",
            "complexity": "MEDIUM",
            "vector": "NETWORK"
        },
        "assigner": "cve@mitre.org",
        "capec": [
            {
                "id": "537",
                "name": "Infiltration of Hardware Development Environment",
                "prerequisites": "The victim must use email or removable media from systems running the IDE (or systems adjacent to the IDE systems). The victim must have a system running exploitable applications and/or a vulnerable configuration to allow for initial infiltration. The attacker must have working knowledge of some if not all of the components involved in the IDE system as well as the infrastructure.",
                "related_weakness": [
                    "125"
                ],
                "solutions": "",
                "summary": "An attacker, leveraging the ability to manipulate components of primary support systems and tools within the development and production environments, inserts malicious software within the hardware and/or firmware development environment. The infiltration purpose is to alter developed hardware components in a system destined for deployment at the victim's organization, for the purpose of disruption or further compromise."
            },
            {
                "id": "540",
                "name": "Overread Buffers",
                "prerequisites": "For this type of attack to be successful, a few prerequisites must be met. First, the targeted software must be written in a language that enables fine grained buffer control. (e.g., c, c++) Second, the targeted software must actually perform buffer operations and inadequately perform bounds-checking on those buffer operations. Finally, the adversary must have the capability to influence the input that guides these buffer operations.",
                "related_weakness": [
                    "125"
                ],
                "solutions": "",
                "summary": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution."
            }
        ],
        "cvss": 4.3,
        "cvss-time": "2021-09-29T21:35:00",
        "cvss-vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
        "cwe": "CWE-125",
        "id": "CVE-2021-41581",
        "impact": {
            "availability": "PARTIAL",
            "confidentiality": "NONE",
            "integrity": "NONE"
        },
        "last-modified": "2021-09-29T21:35:00",
        "references": [
            "https://github.com/libressl-portable/openbsd/issues/126"
        ],
        "summary": "x509_constraints_parse_mailbox in lib/libcrypto/x509/x509_constraints.c in LibreSSL through 3.4.0 has a stack-based buffer over-read. When the input exceeds DOMAIN_PART_MAX_LEN, the buffer lacks '\\0' termination.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T21:34:00",
        "Published": "2021-09-23T18:15:00",
        "access": {
            "authentication": "NONE",
            "complexity": "LOW",
            "vector": "NETWORK"
        },
        "assigner": "cve@mitre.org",
        "capec": [],
        "cvss": 5.0,
        "cvss-time": "2021-09-29T21:34:00",
        "cvss-vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
        "cwe": "CWE-918",
        "id": "CVE-2020-24327",
        "impact": {
            "availability": "NONE",
            "confidentiality": "NONE",
            "integrity": "PARTIAL"
        },
        "last-modified": "2021-09-29T21:34:00",
        "references": [
            "https://github.com/discourse/discourse/pull/10509",
            "https://github.com/purple-WL/Discourse-sending-email-function-exist-Server-side-request-forgery-SSRF-/issues/1"
        ],
        "summary": "Server Side Request Forgery (SSRF) vulnerability exists in Discourse 2.3.2 and 2.6 via the email function. When writing an email in an editor, you can upload pictures of remote websites.",
        "vulnerable_configuration": [
            "cpe:2.3:a:discourse:discourse:2.3.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:discourse:discourse:2.6.0:-:*:*:*:*:*:*"
        ],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": [
            "cpe:2.3:a:discourse:discourse:2.3.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:discourse:discourse:2.6.0:-:*:*:*:*:*:*"
        ]
    },
    {
        "Modified": "2021-09-29T21:33:00",
        "Published": "2021-09-23T20:15:00",
        "access": {
            "authentication": "NONE",
            "complexity": "MEDIUM",
            "vector": "NETWORK"
        },
        "assigner": "cve@mitre.org",
        "capec": [
            {
                "id": "62",
                "name": "Cross Site Request Forgery",
                "prerequisites": "",
                "related_weakness": [
                    "306",
                    "352",
                    "664",
                    "716",
                    "732"
                ],
                "solutions": "Use cryptographic tokens to associate a request with a specific action. The token can be regenerated at every request so that if a request with an invalid token is encountered, it can be reliably discarded. The token is considered invalid if it arrived with a request other than the action it was supposed to be associated with. Although less reliable, the use of the optional HTTP Referrer header can also be used to determine whether an incoming request was actually one that the user is authorized for, in the current context. Additionally, the user can also be prompted to confirm an action every time an action concerning potentially sensitive data is invoked. This way, even if the attacker manages to get the user to click on a malicious link and request the desired action, the user has a chance to recover by denying confirmation. This solution is also implicitly tied to using a second factor of authentication before performing such actions. In general, every request must be checked for the appropriate authentication token as well as authorization in the current session context.",
                "summary": "An attacker crafts malicious web links and distributes them (via web pages, email, etc.), typically in a targeted manner, hoping to induce users to click on the link and execute the malicious action against some third-party application. If successful, the action embedded in the malicious link will be processed and accepted by the targeted application with the users' privilege level. This type of attack leverages the persistence and implicit trust placed in user session cookies by many web applications today. In such an architecture, once the user authenticates to an application and a session cookie is created on the user's system, all following transactions for that session are authenticated using that cookie including potential actions initiated by an attacker and simply \"riding\" the existing session cookie."
            },
            {
                "id": "467",
                "name": "Cross Site Identification",
                "prerequisites": "The victim has an active session with the social networking site.",
                "related_weakness": [
                    "352",
                    "359"
                ],
                "solutions": "Usage: Users should not open other tabs in the browser when using a social networking site.",
                "summary": "An attacker harvests identifying information about a victim via an active session that the victim's browser has with a social networking site. A victim may have the social networking site open in one tab or perhaps is simply using the \"remember me\" feature to keep his or her session with the social networking site active. An attacker induces a payload to execute in the victim's browser that transparently to the victim initiates a request to the social networking site (e.g., via available social network site APIs) to retrieve identifying information about a victim. While some of this information may be public, the attacker is able to harvest this information in context and may use it for further attacks on the user (e.g., spear phishing). In one example of an attack, an attacker may post a malicious posting that contains an image with an embedded link. The link actually requests identifying information from the social networking site. A victim who views the malicious posting in his or her browser will have sent identifying information to the attacker, as long as the victim had an active session with the social networking site. There are many other ways in which the attacker may get the payload to execute in the victim's browser mainly by finding a way to hide it in some reputable site that the victim visits. The attacker could also send the link to the victim in an e-mail and trick the victim into clicking on the link. This attack is basically a cross site request forgery attack with two main differences. First, there is no action that is performed on behalf of the user aside from harvesting information. So standard CSRF protection may not work in this situation. Second, what is important in this attack pattern is the nature of the data being harvested, which is identifying information that can be obtained and used in context. This real time harvesting of identifying information can be used as a prelude for launching real time targeted social engineering attacks on the victim."
            },
            {
                "id": "111",
                "name": "JSON Hijacking (aka JavaScript Hijacking)",
                "prerequisites": "JSON is used as a transport mechanism between the client and the server The target server cannot differentiate real requests from forged requests The JSON object returned from the server can be accessed by the attackers' malicious code via a script tag",
                "related_weakness": [
                    "345",
                    "346",
                    "352"
                ],
                "solutions": "Ensure that server side code can differentiate between legitimate requests and forged requests. The solution is similar to protection against Cross Site Request Forger (CSRF), which is to use a hard to guess random nonce (that is unique to the victim's session with the server) that the attacker has no way of knowing (at least in the absence of other weaknesses). Each request from the client to the server should contain this nonce and the server should reject all requests that do not contain the nonce. On the client side, the system's design could make it difficult to get access to the JSON object content via the script tag. Since the JSON object is never assigned locally to a variable, it cannot be readily modified by the attacker before being used by a script tag. For instance, if while(1) was added to the beginning of the JavaScript returned by the server, trying to access it with a script tag would result in an infinite loop. On the other hand, legitimate client side code can remove the while(1) statement after which the JavaScript can be evaluated. A similar result can be achieved by surrounding the returned JavaScript with comment tags, or using other similar techniques (e.g. wrapping the JavaScript with HTML tags). Make the URLs in the system used to retrieve JSON objects unpredictable and unique for each user session. Ensure that to the extent possible, no sensitive data is passed from the server to the client via JSON objects. JavaScript was never intended to play that role, hence the same origin policy does not adequate address this scenario.",
                "summary": "An attacker targets a system that uses JavaScript Object Notation (JSON) as a transport mechanism between the client and the server (common in Web 2.0 systems using AJAX) to steal possibly confidential information transmitted from the server back to the client inside the JSON object by taking advantage of the loophole in the browser's Same Origin Policy that does not prohibit JavaScript from one website to be included and executed in the context of another website. An attacker gets the victim to visit his or her malicious page that contains a script tag whose source points to the vulnerable system with a URL that requests a response from the server containing a JSON object with possibly confidential information. The malicious page also contains malicious code to capture the JSON object returned by the server before any other processing on it can take place, typically by overriding the JavaScript function used to create new objects. This hook allows the malicious code to get access to the creation of each object and transmit the possibly sensitive contents of the captured JSON object to the attackers' server. There is nothing in the browser's security model to prevent the attackers' malicious JavaScript code (originating from attacker's domain) to set up an environment (as described above) to intercept a JSON object response (coming from the vulnerable target system's domain), read its contents and transmit to the attackers' controlled site. The same origin policy protects the domain object model (DOM), but not the JSON."
            },
            {
                "id": "462",
                "name": "Cross-Domain Search Timing",
                "prerequisites": "Ability to issue GET / POST requests cross domainJava Script is enabled in the victim's browserThe victim has an active session with the site from which the attacker would like to receive informationThe victim's site does not protect search functionality with cross site request forgery (CSRF) protection",
                "related_weakness": [
                    "208",
                    "352",
                    "385"
                ],
                "solutions": "Design: The browser's security model could be fixed to not leak timing information for cross domain requests",
                "summary": "An attacker initiates cross domain HTTP / GET requests and times the server responses. The timing of these responses may leak important information on what is happening on the server. Browser's same origin policy prevents the attacker from directly reading the server responses (in the absence of any other weaknesses), but does not prevent the attacker from timing the responses to requests that the attacker issued cross domain. For GET requests an attacker could for instance leverage the \"img\" tag in conjunction with \"onload() / onerror()\" javascript events. For the POST requests, an attacker could leverage the \"iframe\" element and leverage the \"onload()\" event. There is nothing in the current browser security model that prevents an attacker to use these methods to time responses to the attackers' cross domain requests. The timing for these responses leaks information. For instance, if a victim has an active session with their online e-mail account, an attacker could issue search requests in the victim's mailbox. While the attacker is not able to view the responses, based on the timings of the responses, the attacker could ask yes / no questions as to the content of victim's e-mails, who the victim e-mailed, when, etc. This is but one example; There are other scenarios where an attacker could infer potentially sensitive information from cross domain requests by timing the responses while asking the right questions that leak information."
            }
        ],
        "cvss": 6.8,
        "cvss-time": "2021-09-29T21:33:00",
        "cvss-vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
        "cwe": "CWE-352",
        "id": "CVE-2020-19951",
        "impact": {
            "availability": "PARTIAL",
            "confidentiality": "PARTIAL",
            "integrity": "PARTIAL"
        },
        "last-modified": "2021-09-29T21:33:00",
        "references": [
            "https://github.com/yzmcms/yzmcms/issues/43"
        ],
        "summary": "A cross-site request forgery (CSRF) in /controller/pay.class.php of YzmCMS v5.5 allows attackers to access sensitive components of the application.",
        "vulnerable_configuration": [
            "cpe:2.3:a:yzmcms:yzmcms:5.5:*:*:*:*:*:*:*"
        ],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": [
            "cpe:2.3:a:yzmcms:yzmcms:5.5:*:*:*:*:*:*:*"
        ]
    },
    {
        "Modified": "2021-09-29T21:15:00",
        "Published": "2021-09-29T21:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-41795",
        "impact": {},
        "last-modified": "2021-09-29T21:15:00",
        "references": [
            "https://support.1password.com/kb/202109/"
        ],
        "summary": "The Safari app extension bundled with 1Password for Mac 7.7.0 through 7.8.x before 7.8.7 is vulnerable to authorization bypass. By targeting a vulnerable component of this extension, a malicious web page could read a subset of 1Password vault items that would normally be fillable by the user on that web page. These items are usernames and passwords for vault items associated with its domain, usernames and passwords without a domain association, credit cards, and contact items. (1Password must be unlocked for these items to be accessible, but no further user interaction is required.)",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T21:13:00",
        "Published": "2021-09-24T03:15:00",
        "access": {
            "authentication": "NONE",
            "complexity": "LOW",
            "vector": "NETWORK"
        },
        "assigner": "cve@mitre.org",
        "capec": [
            {
                "id": "577",
                "name": "Owner Footprinting",
                "prerequisites": "The adversary must have gained access to the target system via physical or logical means in order to carry out this attack. Administrator permissions are required to view the home folder of other users.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Ensure that proper permissions on files and folders are enacted to limit accessibility.",
                "summary": "An adversary exploits functionality meant to identify information about the primary users on the target system to an authorized user. They may do this, for example, by reviewing logins or file modification times. By knowing what owners use the target system, the adversary can inform further and more targeted malicious behavior. An example Windows command that may accomplish this is \"dir /A ntuser.dat\". Which will display the last modified time of a user's ntuser.dat file when run within the root folder of a user. This time is synonymous with the last time that user was logged in."
            },
            {
                "id": "643",
                "name": "Identify Shared Files/Directories on System",
                "prerequisites": "The adversary must have obtained logical access to the system by some means (e.g., via obtained credentials or planting malware on the system).",
                "related_weakness": [
                    "200",
                    "267"
                ],
                "solutions": "Identify unnecessary system utilities or potentially malicious software that may contain functionality to identify network share information, and audit and/or block them by using whitelisting tools.",
                "summary": "An adversary discovers connections between systems by exploiting the target system's standard practice of revealing them in searchable, common areas. Through the identification of shared folders/drives between systems, the adversary may further their goals of locating and collecting sensitive information/files, or map potential routes for lateral movement within the network."
            },
            {
                "id": "285",
                "name": "ICMP Echo Request Ping",
                "prerequisites": "The ability to send an ICMP type 8 query (Echo Request) to a remote target and receive an ICMP type 0 message (ICMP Echo Reply) in response. Any firewalls or access control lists between the sender and receiver must allow ICMP Type 8 and ICMP Type 0 messages in order for a ping operation to succeed.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Consider configuring firewall rules to block ICMP Echo requests and prevent replies. If not practical, monitor and consider action when a system has fast and a repeated pattern of requests that move incrementally through port numbers.",
                "summary": "An adversary sends out an ICMP Type 8 Echo Request, commonly known as a 'Ping', in order to determine if a target system is responsive. If the request is not blocked by a firewall or ACL, the target host will respond with an ICMP Type 0 Echo Reply datagram. This type of exchange is usually referred to as a 'Ping' due to the Ping utility present in almost all operating systems. Ping, as commonly implemented, allows a user to test for alive hosts, measure round-trip time, and measure the percentage of packet loss. Performing this operation for a range of hosts on the network is known as a 'Ping Sweep'. While the Ping utility is useful for small-scale host discovery, it was not designed for rapid or efficient host discovery over large network blocks. Other scanning utilities have been created that make ICMP ping sweeps easier to perform. Most networks filter ingress ICMP Type 8 messages for security reasons. Various other methods of performing ping sweeps have developed as a result. It is important to recognize the key security goal of the adversary is to discover if an IP address is alive, or has a responsive host. To this end, virtually any type of ICMP message, as defined by RFC 792 is useful. An adversary can cycle through various types of ICMP messages to determine if holes exist in the firewall configuration. When ICMP ping sweeps fail to discover hosts, other protocols can be used for the same purpose, such as TCP SYN or ACK segments, UDP datagrams sent to closed ports, etc."
            },
            {
                "id": "291",
                "name": "DNS Zone Transfers",
                "prerequisites": "Access to a DNS server that allows Zone transfers.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An attacker exploits a DNS misconfiguration that permits a ZONE transfer. Some external DNS servers will return a list of IP address and valid hostnames. Under certain conditions, it may even be possible to obtain Zone data about the organization's internal network. When successful the attacker learns valuable information about the topology of the target organization, including information about particular servers, their role within the IT structure, and possibly information about the operating systems running upon the network. This is configuration dependent behavior so it may also be required to search out multiple DNS servers while attempting to find one with ZONE transfers allowed."
            },
            {
                "id": "299",
                "name": "TCP SYN Ping",
                "prerequisites": "The ability to send a TCP SYN packet to a remote target. Depending upon the operating system, the ability to craft SYN packets may require elevated privileges.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary uses TCP SYN packets as a means towards host discovery. Typical RFC 793 behavior specifies that when a TCP port is open, a host must respond to an incoming SYN \"synchronize\" packet by completing stage two of the 'three-way handshake' - by sending an SYN/ACK in response. When a port is closed, RFC 793 behavior is to respond with a RST \"reset\" packet. This behavior can be used to 'ping' a target to see if it is alive by sending a TCP SYN packet to a port and then looking for a RST or an ACK packet in response. Due to the different responses from open and closed ports, SYN packets can be used to determine the remote state of the port. A TCP SYN ping is also useful for discovering alive hosts protected by a stateful firewall. In cases where a specific firewall rule does not block access to a port, a SYN packet can pass through the firewall to the host and solicit a response from either an open or closed port. When a stateful firewall is present, SYN pings are preferable to ACK pings because a stateful firewall will typically drop all unsolicited ACK packets as they are not part of an existing or new connection. TCP SYN pings often fail when a stateless ACL or firewall is configured to blanket-filter incoming packets to a port. The firewall device will discard any SYN packets to a blocked port. Often, an adversary will alternate between SYN and ACK pings to discover if a host is alive."
            },
            {
                "id": "305",
                "name": "TCP ACK Scan",
                "prerequisites": "The adversary requires logical access to the target network. ACK scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary uses TCP ACK segments to gather information about firewall or ACL configuration. The purpose of this type of scan is to discover information about filter configurations rather than port state. This type of scanning is rarely useful alone, but when combined with SYN scanning, gives a more complete picture of the type of firewall rules that are present. When a TCP ACK segment is sent to a closed port, or sent out-of-sync to a listening port, the RFC 793 expected behavior is for the device to respond with a RST. Getting RSTs back in response to a ACK scan gives the attacker useful information that can be used to infer the type of firewall present. Stateful firewalls will discard out-of-sync ACK packets, leading to no response. When this occurs the port is marked as filtered. When RSTs are received in response, the ports are marked as unfiltered, as the ACK packets solicited the expected behavior from a port. When combined with SYN techniques an attacker can gain a more complete picture of which types of packets get through to a host and thereby map out its firewall rule-set. ACK scanning, when combined with SYN scanning, also allows the adversary to analyze whether a firewall is stateful or non-stateful. If a SYN solicits a SYN/ACK or a RST and an ACK solicits a RST, the port is unfiltered by any firewall type. If a SYN solicits a SYN/ACK, but an ACK generates no response, the port is statefully filtered. When a SYN generates neither a SYN/ACK or a RST, but an ACK generates a RST, the port is statefully filtered. When neither SYN nor ACK generates any response, the port is blocked by a specific firewall rule, which can occur via any type of firewall. TCP ACK Scans are somewhat faster and more stealthy than other types of scans but often requires rather sophisticated analysis by an experienced person. A skilled adversary may use this method to map out firewall rules, but the results of ACK scanning will be less useful to a novice."
            },
            {
                "id": "310",
                "name": "Scanning for Vulnerable Software",
                "prerequisites": "Access to the network on which the targeted system resides. Software tools used to probe systems over a range of ports and protocols.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An attacker engages in scanning activity to find vulnerable software versions or types, such as operating system versions or network services. Vulnerable or exploitable network configurations, such as improperly firewalled systems, or misconfigured systems in the DMZ or external network, provide windows of opportunity for an attacker. Common types of vulnerable software include unpatched operating systems or services (e.g FTP, Telnet, SMTP, SNMP) running on open ports that the attacker has identified. Attackers usually begin probing for vulnerable software once the external network has been port scanned and potential targets have been revealed."
            },
            {
                "id": "317",
                "name": "IP ID Sequencing Probe",
                "prerequisites": "",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "This OS fingerprinting probe analyzes the IP 'ID' field sequence number generation algorithm of a remote host. Operating systems generate IP 'ID' numbers differently, allowing an attacker to identify the operating system of the host by examining how is assigns ID numbers when generating response packets. RFC 791 does not specify how ID numbers are chosen or their ranges, so ID sequence generation differs from implementation to implementation. There are two kinds of IP 'ID' sequence number analysis - IP 'ID' Sequencing: analyzing the IP 'ID' sequence generation algorithm for one protocol used by a host and Shared IP 'ID' Sequencing: analyzing the packet ordering via IP 'ID' values spanning multiple protocols, such as between ICMP and TCP."
            },
            {
                "id": "326",
                "name": "TCP Initial Window Size Probe",
                "prerequisites": "The ability to monitor and interact with network communications.Access to at least one host, and the privileges to interface with the network interface card.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "This OS fingerprinting probe checks the initial TCP Window size. TCP stacks limit the range of sequence numbers allowable within a session to maintain the \"connected\" state within TCP protocol logic. The initial window size specifies a range of acceptable sequence numbers that will qualify as a response to an ACK packet within a session. Various operating systems use different Initial window sizes. The initial window size can be sampled by establishing an ordinary TCP connection."
            },
            {
                "id": "330",
                "name": "ICMP Error Message Echoing Integrity Probe",
                "prerequisites": "The ability to monitor and interact with network communications.Access to at least one host, and the privileges to interface with the network interface card.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary uses a technique to generate an ICMP Error message (Port Unreachable, Destination Unreachable, Redirect, Source Quench, Time Exceeded, Parameter Problem) from a target and then analyze the integrity of data returned or \"Quoted\" from the originating request that generated the error message. For this purpose \"Port Unreachable\" error messages are often used, as generating them requires the attacker to send a UDP datagram to a closed port on the target. When replying with an ICMP error message some IP/ICMP stack implementations change aspects of the IP header, change or reverse certain byte orders, reset certain field values to default values which differ between operating system and firmware implementations, and make other changes. Some IP/ICMP stacks are decidedly broken, indicating an idiosyncratic behavior that differs from the RFC specifications, such as the case when miscalculations affect a field value. A tremendous amount of information about the host operating system can be deduced from its 'echoing' characteristics. Notably, inspection of key protocol header fields, including the echoed header fields of the encapsulating protocol can yield a wealth of data about the host operating system or firmware version."
            },
            {
                "id": "574",
                "name": "Services Footprinting",
                "prerequisites": "The adversary must have gained access to the target system via physical or logical means in order to carry out this attack.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Identify programs that may be used to acquire service information and block them by using a software restriction policy or tools that restrict program execution by process whitelisting.",
                "summary": "An adversary exploits functionality meant to identify information about the services on the target system to an authorized user. By knowing what services are registered on the target system, the adversary can learn about the target environment as a means towards further malicious behavior. Depending on the operating system, commands that can obtain services information include \"sc\" and \"tasklist/svc\" using Tasklist, and \"net start\" using Net."
            },
            {
                "id": "292",
                "name": "Host Discovery",
                "prerequisites": "The adversary requires logical access to the target network in order to carry out host discovery.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary sends a probe to an IP address to determine if the host is alive. Host discovery is one of the earliest phases of network reconnaissance. The adversary usually starts with a range of IP addresses belonging to a target network and uses various methods to determine if a host is present at that IP address. Host discovery is usually referred to as 'Ping' scanning using a sonar analogy. The goal is to send a packet through to the IP address and solicit a response from the host. As such, a 'ping' can be virtually any crafted packet whatsoever, provided the adversary can identify a functional host based on its response. An attack of this nature is usually carried out with a 'ping sweep,' where a particular kind of ping is sent to a range of IP addresses."
            },
            {
                "id": "301",
                "name": "TCP Connect Scan",
                "prerequisites": "The adversary requires logical access to the target network. The TCP connect Scan requires the ability to connect to an available port and complete a 'three-way-handshake' This scanning technique does not require any special privileges in order to perform. This type of scan works against all TCP/IP stack implementations.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Employ a robust network defense posture that includes an IDS/IPS system.",
                "summary": "An adversary uses full TCP connection attempts to determine if a port is open on the target system. The scanning process involves completing a 'three-way handshake' with a remote port, and reports the port as closed if the full handshake cannot be established. An advantage of TCP connect scanning is that it works against any TCP/IP stack. RFC 793 defines how TCP connections are established and torn down. TCP connect scanning commonly involves establishing a full connection, and then subsequently tearing it down, and therefore involves sending a significant number of packets to each port that is scanned. Compared to other types of scans, a TCP Connect scan is slow and methodical. This type of scanning causes considerable noise in system logs and can be spotted by IDS/IPS systems. TCP Connect scanning can detect when a port is open by completing the three-way handshake, but it cannot distinguish a port that is unfiltered with no service running on it from a port that is filtered by a firewall but contains an active service. Due to the significant volume of packets exchanged per port, TCP connect scanning can become very time consuming (performing a full TCP connect scan against a host can take multiple days). Generally, it is not used as a method for performing a comprehensive port scan, but is reserved for checking a short list of common ports."
            },
            {
                "id": "290",
                "name": "Enumerate Mail Exchange (MX) Records",
                "prerequisites": "The adversary requires access to a DNS server that will return the MX records for a network.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary enumerates the MX records for a given via a DNS query. This type of information gathering returns the names of mail servers on the network. Mail servers are often not exposed to the Internet but are located within the DMZ of a network protected by a firewall. A side effect of this configuration is that enumerating the MX records for an organization my reveal the IP address of the firewall or possibly other internal systems. Attackers often resort to MX record enumeration when a DNS Zone Transfer is not possible."
            },
            {
                "id": "298",
                "name": "UDP Ping",
                "prerequisites": "The adversary requires the ability to send a UDP datagram to a remote host and receive a response. The adversary requires the ability to craft custom UDP Packets for use during network reconnaissance. The target's firewall must not be configured to block egress ICMP messages.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Configure your firewall to block egress ICMP messages.",
                "summary": "An adversary sends a UDP datagram to the remote host to determine if the host is alive. If a UDP datagram is sent to an open UDP port there is very often no response, so a typical strategy for using a UDP ping is to send the datagram to a random high port on the target. The goal is to solicit an 'ICMP port unreachable' message from the target, indicating that the host is alive. UDP pings are useful because some firewalls are not configured to block UDP datagrams sent to strange or typically unused ports, like ports in the 65K range. Additionally, while some firewalls may filter incoming ICMP, weaknesses in firewall rule-sets may allow certain types of ICMP (host unreachable, port unreachable) which are useful for UDP ping attempts."
            },
            {
                "id": "306",
                "name": "TCP Window Scan",
                "prerequisites": "TCP Window scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary engages in TCP Window scanning to analyze port status and operating system type. TCP Window scanning uses the ACK scanning method but examine the TCP Window Size field of response RST packets to make certain inferences. While TCP Window Scans are fast and relatively stealthy, they work against fewer TCP stack implementations than any other type of scan. Some operating systems return a positive TCP window size when a RST packet is sent from an open port, and a negative value when the RST originates from a closed port. TCP Window scanning is one of the most complex scan types, and its results are difficult to interpret. Window scanning alone rarely yields useful information, but when combined with other types of scanning is more useful. It is a generally more reliable means of making inference about operating system versions than port status."
            },
            {
                "id": "322",
                "name": "TCP (ISN) Greatest Common Divisor Probe",
                "prerequisites": "The ability to monitor and interact with network communications.Access to at least one host, and the privileges to interface with the network interface card.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "This OS fingerprinting probe sends a number of TCP SYN packets to an open port of a remote machine. The Initial Sequence Number (ISN) in each of the SYN/ACK response packets is analyzed to determine the smallest number that the target host uses when incrementing sequence numbers. This information can be useful for identifying an operating system because particular operating systems and versions increment sequence numbers using different values. The result of the analysis is then compared against a database of OS behaviors to determine the OS type and/or version."
            },
            {
                "id": "325",
                "name": "TCP Congestion Control Flag (ECN) Probe",
                "prerequisites": "The ability to monitor and interact with network communications.Access to at least one host, and the privileges to interface with the network interface card.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "This OS fingerprinting probe checks to see if the remote host supports explicit congestion notification (ECN) messaging. ECN messaging was designed to allow routers to notify a remote host when signal congestion problems are occurring. Explicit Congestion Notification messaging is defined by RFC 3168. Different operating systems and versions may or may not implement ECN notifications, or may respond uniquely to particular ECN flag types."
            },
            {
                "id": "224",
                "name": "Fingerprinting",
                "prerequisites": "A means by which to interact with the target system directly.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "While some information is shared by systems automatically based on standards and protocols, remove potentially sensitive information that is not necessary for the application's functionality as much as possible.",
                "summary": "An adversary compares output from a target system to known indicators that uniquely identify specific details about the target. Fingerprinting by itself is not usually detrimental to the target. However, the information gathered through fingerprinting often enables an adversary to discover existing weaknesses in the target."
            },
            {
                "id": "297",
                "name": "TCP ACK Ping",
                "prerequisites": "The ability to send an ACK packet to a remote host and identify the response. Creating the ACK packet without building a full connection requires the use of raw sockets. As a result, it is not possible to send a TCP ACK ping from some systems (Windows XP SP 2) without the use of third-party packet drivers like Winpcap. On other systems (BSD, Linux) administrative privileges are required in order to write to the raw socket. The target must employ a stateless firewall that lacks a rule set that rejects unsolicited ACK packets. The adversary requires the ability to craft custom TCP ACK segments for use during network reconnaissance. Sending an ACK ping requires the ability to access \"raw sockets\" in order to create the packets with direct access to the packet header.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Leverage stateful firewalls that allow for the rejection of a packet that is not part of an existing connection.",
                "summary": "An adversary sends a TCP segment with the ACK flag set to a remote host for the purpose of determining if the host is alive. This is one of several TCP 'ping' types. The RFC 793 expected behavior for a service is to respond with a RST 'reset' packet to any unsolicited ACK segment that is not part of an existing connection. So by sending an ACK segment to a port, the adversary can identify that the host is alive by looking for a RST packet. Typically, a remote server will respond with a RST regardless of whether a port is open or closed. In this way, TCP ACK pings cannot discover the state of a remote port because the behavior is the same in either case. The firewall will look up the ACK packet in its state-table and discard the segment because it does not correspond to any active connection. A TCP ACK Ping can be used to discover if a host is alive via RST response packets sent from the host."
            },
            {
                "id": "309",
                "name": "Network Topology Mapping",
                "prerequisites": "None",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary engages in scanning activities to map network nodes, hosts, devices, and routes. Adversaries usually perform this type of network reconnaissance during the early stages of attack against an external network. Many types of scanning utilities are typically employed, including ICMP tools, network mappers, port scanners, and route testing utilities such as traceroute."
            },
            {
                "id": "318",
                "name": "IP 'ID' Echoed Byte-Order Probe",
                "prerequisites": "",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "This OS fingerprinting probe tests to determine if the remote host echoes back the IP 'ID' value from the probe packet. An attacker sends a UDP datagram with an arbitrary IP 'ID' value to a closed port on the remote host to observe the manner in which this bit is echoed back in the ICMP error message. The identification field (ID) is typically utilized for reassembling a fragmented packet. Some operating systems or router firmware reverse the bit order of the ID field when echoing the IP Header portion of the original datagram within an ICMP error message."
            },
            {
                "id": "328",
                "name": "TCP 'RST' Flag Checksum Probe",
                "prerequisites": "The ability to monitor and interact with network communications.Access to at least one host, and the privileges to interface with the network interface card.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "This OS fingerprinting probe performs a checksum on any ASCII data contained within the data portion or a RST packet. Some operating systems will report a human-readable text message in the payload of a 'RST' (reset) packet when specific types of connection errors occur. RFC 1122 allows text payloads within reset packets but not all operating systems or routers implement this functionality."
            },
            {
                "id": "295",
                "name": "Timestamp Request",
                "prerequisites": "The ability to send a timestamp request to a remote target and receive a response.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "This pattern of attack leverages standard requests to learn the exact time associated with a target system. An adversary may be able to use the timestamp returned from the target to attack time-based security algorithms, such as random number generators, or time-based authentication mechanisms."
            },
            {
                "id": "300",
                "name": "Port Scanning",
                "prerequisites": "The adversary requires logical access to the target's network in order to carry out this type of attack.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary uses a combination of techniques to determine the state of the ports on a remote target. Any service or application available for TCP or UDP networking will have a port open for communications over the network. Although common services have assigned port numbers, services and applications can run on arbitrary ports. Additionally, port scanning is complicated by the potential for any machine to have up to 65535 possible UDP or TCP services. The goal of port scanning is often broader than identifying open ports, but also give the adversary information concerning the firewall configuration. Depending upon the method of scanning that is used, the process can be stealthy or more obtrusive, the latter being more easily detectable due to the volume of packets involved, anomalous packet traits, or system logging. Typical port scanning activity involves sending probes to a range of ports and observing the responses. There are four types of port status that this type of attack aims to identify: 1) Open Port: The port is open and a firewall does not block access to the port, 2) Closed Port: The port is closed (i.e. no service resides there) and a firewall does not block access to the port, 3) Filtered Port: A firewall or ACL rule is blocking access to the port in some manner, although the presence of a listening service on the port cannot be verified, and 4) Unfiltered Port: A firewall or ACL rule is not blocking access to the port, although the presence of a listening service on the port cannot be verified. For strategic purposes it is useful for an adversary to distinguish between an open port that is protected by a filter vs. a closed port that is not protected by a filter. Making these fine grained distinctions is impossible with certain scan types. A TCP connect scan, for instance, cannot distinguish a blocked port with an active service from a closed port that is not firewalled. Other scan types can only detect closed ports, while others cannot detect port state at all, only the presence or absence of filters. Collecting this type of information tells the adversary which ports can be attacked directly, which must be attacked with filter evasion techniques like fragmentation, source port scans, and which ports are unprotected (i.e. not firewalled) but aren't hosting a network service. An adversary often combines various techniques in order to gain a more complete picture of the firewall filtering mechanisms in place for a host."
            },
            {
                "id": "307",
                "name": "TCP RPC Scan",
                "prerequisites": "RPC scanning requires no special privileges when it is performed via a native system utility.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Typically, an IDS/IPS system is very effective against this type of attack.",
                "summary": "An adversary scans for RPC services listing on a Unix/Linux host. This type of scan can be obtained via native operating system utilities or via port scanners like nmap. When performed by a scanner, an RPC datagram is sent to a list of UDP ports and the response is recorded. Particular types of responses can be indicative of well-known RPC services running on a UDP port. Direct RPC scans that bypass portmapper/sunrpc are typically slow compare to other scan types, are easily detected by IPS/IDS systems, and can only detect open ports when an RPC service responds. ICMP diagnostic message responses can help identify closed ports, however filtered and unfiltered ports cannot be identified through TCP RPC scans. There are two general approaches to RPC scanning: One is to use a native operating system utility, or script, to query the portmapper/rpcbind application running on port 111. Portmapper will return a list of registered RPC services. Alternately, one can use a port scanner or script to scan for RPC services directly. Discovering RPC services gives the attacker potential targets to attack, as some RPC services are insecure by default."
            },
            {
                "id": "313",
                "name": "Passive OS Fingerprinting",
                "prerequisites": "The ability to monitor network communications.Access to at least one host, and the privileges to interface with the network interface card.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary engages in activity to detect the version or type of OS software in a an environment by passively monitoring communication between devices, nodes, or applications. Passive techniques for operating system detection send no actual probes to a target, but monitor network or client-server communication between nodes in order to identify operating systems based on observed behavior as compared to a database of known signatures or values. While passive OS fingerprinting is not usually as reliable as active methods, it is generally better able to evade detection."
            },
            {
                "id": "319",
                "name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
                "prerequisites": "",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "This OS fingerprinting probe tests to determine if the remote host echoes back the IP 'DF' (Don't Fragment) bit in a response packet. An attacker sends a UDP datagram with the DF bit set to a closed port on the remote host to observe whether the 'DF' bit is set in the response packet. Some operating systems will echo the bit in the ICMP error message while others will zero out the bit in the response packet."
            },
            {
                "id": "327",
                "name": "TCP Options Probe",
                "prerequisites": "The ability to monitor and interact with network communications.Access to at least one host, and the privileges to interface with the network interface card.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "This OS fingerprinting probe analyzes the type and order of any TCP header options present within a response segment. Most operating systems use unique ordering and different option sets when options are present. RFC 793 does not specify a required order when options are present, so different implementations use unique ways of ordering or structuring TCP options. TCP options can be generated by ordinary TCP traffic."
            },
            {
                "id": "59",
                "name": "Session Credential Falsification through Prediction",
                "prerequisites": "The target host uses session IDs to keep track of the users. Session IDs are used to control access to resources. The session IDs used by the target host are predictable. For example, the session IDs are generated using predictable information (e.g., time).",
                "related_weakness": [
                    "200",
                    "285",
                    "290",
                    "330",
                    "331",
                    "346",
                    "384",
                    "488",
                    "539",
                    "6",
                    "693",
                    "719"
                ],
                "solutions": "Use a strong source of randomness to generate a session ID. Use adequate length session IDs Do not use information available to the user in order to generate session ID (e.g., time). Ideas for creating random numbers are offered by Eastlake [RFC1750] Encrypt the session ID if you expose it to the user. For instance session ID can be stored in a cookie in encrypted format.",
                "summary": "This attack targets predictable session ID in order to gain privileges. The attacker can predict the session ID used during a transaction to perform spoofing and session hijacking."
            },
            {
                "id": "302",
                "name": "TCP FIN Scan",
                "prerequisites": "FIN scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary uses a TCP FIN scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with the FIN bit set in the packet header. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow the adversary to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. In addition to its relative speed in comparison with other types of scans, the major advantage a TCP FIN Scan is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to 'build' a connection. FIN packets, like out-of-state ACK packets, tend to pass through such devices undetected. Many operating systems, however, do not implement RFC 793 exactly and for this reason FIN scans do not work as expected against these devices. Some operating systems, like Microsoft Windows, send a RST packet in response to any out-of-sync (or malformed) TCP segments received by a listening socket (rather than dropping the packet via RFC 793), thus preventing an attacker from distinguishing between open and closed ports. FIN scans are limited by the range of platforms against which they work. Additionally, because open ports are inferred via no responses being generated, one cannot distinguish an open port from a filtered port without further analysis. For instance, FIN scanning a system protected by a stateful firewall may indicate all ports being open. For these reasons, FIN scanning results must always be interpreted as part of a larger scanning strategy. FIN scanning is still relatively stealthy as the packets tend to blend in with the background noise on a network link. FIN scans are detected via heuristic (non-signature) based algorithms, much in the same way as other scan types are detected."
            },
            {
                "id": "323",
                "name": "TCP (ISN) Counter Rate Probe",
                "prerequisites": "The ability to monitor and interact with network communications.Access to at least one host, and the privileges to interface with the network interface card.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "This OS detection probe measures the average rate of initial sequence number increments during a period of time. Sequence numbers are incremented using a time-based algorithm and are susceptible to a timing analysis that can determine the number of increments per unit time. The result of this analysis is then compared against a database of operating systems and versions to determine likely operation system matches."
            },
            {
                "id": "573",
                "name": "Process Footprinting",
                "prerequisites": "The adversary must have gained access to the target system via physical or logical means in order to carry out this attack.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Identify programs that may be used to acquire process information and block them by using a software restriction policy or tools that restrict program execution by process whitelisting.",
                "summary": "An adversary exploits functionality meant to identify information about the currently running processes on the target system to an authorized user. By knowing what processes are running on the target system, the adversary can learn about the target environment as a means towards further malicious behavior."
            },
            {
                "id": "616",
                "name": "Establish Rogue Location",
                "prerequisites": "A resource is expected to available to the user.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary provides a malicious version of a resource at a location that is similar to the expected location of a legitimate resource. After establishing the rogue location, the adversary waits for a victim to visit the location and access the malicious resource."
            },
            {
                "id": "646",
                "name": "Peripheral Footprinting",
                "prerequisites": "The adversary needs either physical or remote access to the victim system.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Identify programs that may be used to acquire peripheral information and block them by using a software restriction policy or tools that restrict program execution by process whitelisting.",
                "summary": "Adversaries may attempt to obtain information about attached peripheral devices and components connected to a computer system. Examples may include discovering the presence of iOS devices by searching for backups, analyzing the Windows registry to determine what USB devices have been connected, or infecting a victim system with malware to report when a USB device has been connected. This may allow the adversary to gain additional insight about the system or network environment, which may be useful in constructing further attacks."
            },
            {
                "id": "296",
                "name": "ICMP Information Request",
                "prerequisites": "The ability to send an ICMP Type 15 Information Request and receive an ICMP Type 16 Information Reply in response.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary sends an ICMP Information Request to a host to determine if it will respond to this deprecated mechanism. ICMP Information Requests are a deprecated message type. Information Requests were originally used for diskless machines to automatically obtain their network configuration, but this message type has been superseded by more robust protocol implementations like DHCP."
            },
            {
                "id": "303",
                "name": "TCP Xmas Scan",
                "prerequisites": "The adversary needs logical access to the target network. XMAS scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Employ a robust network defensive posture that includes a managed IDS/IPS.",
                "summary": "An adversary uses a TCP XMAS scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with the all flags sent in the packet header, generating packets that are illegal based on RFC 793. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow an attacker to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. In addition to its relative speed when compared with other types of scans, its major advantage is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to 'build' a connection. XMAS packets, like out-of-state FIN or ACK packets, tend to pass through such devices undetected. Many operating systems, however, do not implement RFC 793 exactly and for this reason FIN scans do not work as expected against these devices. Some operating systems, like Microsoft Windows, send a RST packet in response to any out-of-sync (or malformed) TCP segments received by a listening socket (rather than dropping the packet via RFC 793), thus preventing the adversary from distinguishing between open and closed ports. XMAS scans are limited by the range of platforms against which they work. Additionally, because open ports are inferred via no responses being generated, one cannot distinguish an open port from a filtered port without further analysis. For instance, XMAS scanning a system protected by a stateful firewall may indicate all ports being open. Because of their obvious rule-breaking nature, XMAS scans are flagged by almost all intrusion prevention or intrusion detection systems."
            },
            {
                "id": "312",
                "name": "Active OS Fingerprinting",
                "prerequisites": "The ability to monitor and interact with network communications.Access to at least one host, and the privileges to interface with the network interface card.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary engages in activity to detect the operating system or firmware version of a remote target by interrogating a device, server, or platform with a probe designed to solicit behavior that will reveal information about the operating systems or firmware in the environment. Operating System detection is possible because implementations of common protocols (Such as IP or TCP) differ in distinct ways. While the implementation differences are not sufficient to 'break' compatibility with the protocol the differences are detectable because the target will respond in unique ways to specific probing activity that breaks the semantic or logical rules of packet construction for a protocol. Different operating systems will have a unique response to the anomalous input, providing the basis to fingerprint the OS behavior. This type of OS fingerprinting can distinguish between operating system types and versions."
            },
            {
                "id": "320",
                "name": "TCP Timestamp Probe",
                "prerequisites": "The ability to monitor and interact with network communications.Access to at least one host, and the privileges to interface with the network interface card.The target OS must support the TCP timestamp option in order to obtain a fingerprint.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "This OS fingerprinting probe examines the remote server's implementation of TCP timestamps. Not all operating systems implement timestamps within the TCP header, but when timestamps are used then this provides the attacker with a means to guess the operating system of the target. The attacker begins by probing any active TCP service in order to get response which contains a TCP timestamp. Different Operating systems update the timestamp value using different intervals. This type of analysis is most accurate when multiple timestamp responses are received and then analyzed. TCP timestamps can be found in the TCP Options field of the TCP header."
            },
            {
                "id": "79",
                "name": "Using Slashes in Alternate Encoding",
                "prerequisites": "The application server accepts paths to locate resources. The application server does insufficient input data validation on the resource path requested by the user. The access right to resources are not set properly.",
                "related_weakness": [
                    "171",
                    "173",
                    "180",
                    "181",
                    "185",
                    "20",
                    "200",
                    "21",
                    "22",
                    "697",
                    "707",
                    "73",
                    "74"
                ],
                "solutions": "Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process. Refer to the RFCs to safely decode URL. When client input is required from web-based forms, avoid using the \"GET\" method to submit data, as the method causes the form data to be appended to the URL and is easily manipulated. Instead, use the \"POST method whenever possible. There are tools to scan HTTP requests to the server for valid URL such as URLScan from Microsoft (http://www.microsoft.com/technet/security/tools/urlscan.mspx) Be aware of the threat of alternative method of data encoding and obfuscation technique such as IP address encoding. (See related guideline section) Test your path decoding process against malicious input. In the case of path traversals, use the principle of least privilege when determining access rights to file systems. Do not allow users to access directories/files that they should not access. Assume all input is malicious. Create a white list that defines all valid input to the application based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system.",
                "summary": "This attack targets the encoding of the Slash characters. An attacker would try to exploit common filtering problems related to the use of the slashes characters to gain access to resources on the target host. Directory-driven systems, such as file systems and databases, typically use the slash character to indicate traversal between directories or other container components. For murky historical reasons, PCs (and, as a result, Microsoft OSs) choose to use a backslash, whereas the UNIX world typically makes use of the forward slash. The schizophrenic result is that many MS-based systems are required to understand both forms of the slash. This gives the attacker many opportunities to discover and abuse a number of common filtering problems. The goal of this pattern is to discover server software that only applies filters to one version, but not the other."
            },
            {
                "id": "116",
                "name": "Excavation",
                "prerequisites": "An adversary requires some way of interacting with the system.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Minimize error/response output to only what is necessary for functional use or corrective language. Remove potentially sensitive information that is not necessary for the application's functionality.",
                "summary": "An adversary actively probes the target in a manner that is designed to solicit information that could be leveraged for malicious purposes. This is achieved by exploring the target via ordinary interactions for the purpose of gathering intelligence about the target, or by sending data that is syntactically invalid or non-standard in an attempt to produce a response that contains the desired data. As a result of these interactions, the adversary is able to obtain information from the target that aids the attacker in making inferences about its security, configuration, or potential vulnerabilities. Examplar exchanges with the target may trigger unhandled exceptions or verbose error messages that reveal information like stack traces, configuration information, path information, or database design. This type of attack also includes the manipulation of query strings in a URI to produce invalid SQL queries, or by trying alternative path values in the hope that the server will return useful information."
            },
            {
                "id": "321",
                "name": "TCP Sequence Number Probe",
                "prerequisites": "The ability to monitor and interact with network communications.Access to at least one host, and the privileges to interface with the network interface card.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "This OS fingerprinting probe tests the target system's assignment of TCP sequence numbers. One common way to test TCP Sequence Number generation is to send a probe packet to an open port on the target and then compare the how the Sequence Number generated by the target relates to the Acknowledgement Number in the probe packet. Different operating systems assign Sequence Numbers differently, so a fingerprint of the operating system can be obtained by categorizing the relationship between the acknowledgement number and sequence number as follows: 1) the Sequence Number generated by the target is Zero, 2) the Sequence Number generated by the target is the same as the acknowledgement number in the probe, 3) the Sequence Number generated by the target is the acknowledgement number plus one, or 4) the Sequence Number is any other non-zero number."
            },
            {
                "id": "472",
                "name": "Browser Fingerprinting",
                "prerequisites": "Victim's browser visits a website that contains attacker's Java ScriptJava Script is not disabled in the victim's browser",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Configuration: Disable Java Script in the browser",
                "summary": "An attacker carefully crafts small snippets of Java Script to efficiently detect the type of browser the potential victim is using. Many web-based attacks need prior knowledge of the web browser including the version of browser to ensure successful exploitation of a vulnerability. Having this knowledge allows an attacker to target the victim with attacks that specifically exploit known or zero day weaknesses in the type and version of the browser used by the victim. Automating this process via Java Script as a part of the same delivery system used to exploit the browser is considered more efficient as the attacker can supply a browser fingerprinting method and integrate it with exploit code, all contained in Java Script and in response to the same web page request by the browser."
            },
            {
                "id": "497",
                "name": "File Discovery",
                "prerequisites": "The adversary must know the location of these common key files.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Leverage file protection mechanisms to render these files accessible only to authorized parties.",
                "summary": "An adversary engages in probing and exploration activities to determine if common key files exists. Such files often contain configuration and security parameters of the targeted application, system or network. Using this knowledge may often pave the way for more damaging attacks."
            },
            {
                "id": "575",
                "name": "Account Footprinting",
                "prerequisites": "The adversary must have gained access to the target system via physical or logical means in order to carry out this attack.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Identify programs that may be used to acquire account information and block them by using a software restriction policy or tools that restrict program execution by process whitelisting.",
                "summary": "An adversary exploits functionality meant to identify information about the domain accounts and their permissions on the target system to an authorized user. By knowing what accounts are registered on the target system, the adversary can inform further and more targeted malicious behavior. Example Windows commands which can acquire this information are: \"net user\" and \"dsquery\"."
            },
            {
                "id": "294",
                "name": "ICMP Address Mask Request",
                "prerequisites": "The ability to send an ICMP type 17 query (Address Mask Request) to a remote target and receive an ICMP type 18 message (ICMP Address Mask Reply) in response. Generally, modern operating systems will ignore ICMP type 17 messages, however, routers will commonly respond to this request.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary sends an ICMP Type 17 Address Mask Request to gather information about a target's networking configuration. ICMP Address Mask Requests are defined by RFC-950, \"Internet Standard Subnetting Procedure.\" An Address Mask Request is an ICMP type 17 message that triggers a remote system to respond with a list of its related subnets, as well as its default gateway and broadcast address via an ICMP type 18 Address Mask Reply datagram. Gathering this type of information helps the adversary plan router-based attacks as well as denial-of-service attacks against the broadcast address. Many modern operating systems will not respond to ICMP type 17 messages for security reasons. Determining whether a system or router will respond to an ICMP Address Mask Request helps the adversary determine operating system or firmware version. Additionally, because these types of messages are rare, they are easily spotted by intrusion detection systems. Many ICMP scanning tools support IP spoofing to help conceal the origin of the actual request among a storm of similar ICMP messages. It is a common practice for border firewalls and gateways to be configured to block ingress ICMP type 17 and egress ICMP type 18 messages."
            },
            {
                "id": "304",
                "name": "TCP Null Scan",
                "prerequisites": "The adversary requires logical access to the target network. NULL scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary uses a TCP NULL scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with no flags in the packet header, generating packets that are illegal based on RFC 793. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow an attacker to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. In addition to being fast, the major advantage of this scan type is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to 'build' a connection. NULL packets, like out-of-state FIN or ACK packets, tend to pass through such devices undetected. Many operating systems, however, do not implement RFC 793 exactly and for this reason NULL scans do not work as expected against these devices. Some operating systems, like Microsoft Windows, send a RST packet in response to any out-of-sync (or malformed) TCP segments received by a listening socket (rather than dropping the packet via RFC 793), thus preventing an attacker from distinguishing between open and closed ports. NULL scans are limited by the range of platforms against which they work. Additionally, because open ports are inferred via no responses being generated, one cannot distinguish an open port from a filtered port without further analysis. For instance, NULL scanning a system protected by a stateful firewall may indicate all ports being open. Because of their obvious rule-breaking nature, NULL scans are flagged by almost all intrusion prevention or intrusion detection systems."
            },
            {
                "id": "324",
                "name": "TCP (ISN) Sequence Predictability Probe",
                "prerequisites": "The ability to monitor and interact with network communications.Access to at least one host, and the privileges to interface with the network interface card.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "This type of operating system probe attempts to determine an estimate for how predictable the sequence number generation algorithm is for a remote host. Statistical techniques, such as standard deviation, can be used to determine how predictable the sequence number generation is for a system. This result can then be compared to a database of operating system behaviors to determine a likely match for operating system and version."
            },
            {
                "id": "651",
                "name": "Eavesdropping",
                "prerequisites": "The adversary typically requires physical proximity to the target's environment, whether for physical eavesdropping or for placing recording equipment. This is not always the case for software-based eavesdropping, if the adversary has the capability to install malware on the target system that can activate a microphone and record audio digitally.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Be mindful of your surroundings when discussing sensitive information in public areas. Implement proper software restriction policies to only allow authorized software on your environment. Use of anti-virus and other security monitoring and detecting tools can aid in this too. Closely monitor installed software for unusual behavior or activity, and implement patches as soon as they become available. If possible, physically disable the microphone on your machine if it is not needed.",
                "summary": "An adversary intercepts a form of communication (e.g. text, audio, video) by way of software (e.g., microphone and audio recording application), hardware (e.g., recording equipment), or physical means (e.g., physical proximity). The goal of eavesdropping is typically to gain unauthorized access to sensitive information about the target for financial, personal, political, or other gains. Eavesdropping is different from a sniffing attack as it does not take place on a network-based communication channel (e.g., IP traffic). Instead, it entails listening in on the raw audio source of a conversation between two or more parties."
            },
            {
                "id": "13",
                "name": "Subverting Environment Variable Values",
                "prerequisites": "An environment variable is accessible to the user. An environment variable used by the application can be tainted with user supplied data. Input data used in an environment variable is not validated properly. The variables encapsulation is not done properly. For instance setting a variable as public in a class makes it visible and an attacker may attempt to manipulate that variable.",
                "related_weakness": [
                    "15",
                    "20",
                    "200",
                    "285",
                    "302",
                    "353",
                    "73",
                    "74"
                ],
                "solutions": "Protect environment variables against unauthorized read and write access. Protect the configuration files which contain environment variables against illegitimate read and write access. Assume all input is malicious. Create a white list that defines all valid input to the software system based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system. Apply the least privilege principles. If a process has no legitimate reason to read an environment variable do not give that privilege.",
                "summary": "The attacker directly or indirectly modifies environment variables used by or controlling the target software. The attacker's goal is to cause the target software to deviate from its expected operation in a manner that benefits the attacker."
            },
            {
                "id": "169",
                "name": "Footprinting",
                "prerequisites": "An application must publicize identifiable information about the system or application through voluntary or involuntary means. Certain identification details of information systems are visible on communication networks (e.g., if an adversary uses a sniffer to inspect the traffic) due to their inherent structure and protocol standards. Any system or network that can be detected can be footprinted. However, some configuration choices may limit the useful information that can be collected during a footprinting attack.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Keep patches up to date by installing weekly or daily if possible. Shut down unnecessary services/ports. Change default passwords by choosing strong passwords. Curtail unexpected input. Encrypt and password-protect sensitive data. Avoid including information that has the potential to identify and compromise your organization's security such as access to business plans, formulas, and proprietary documents.",
                "summary": "An adversary engages in probing and exploration activities to identify constituents and properties of the target. Footprinting is a general term to describe a variety of information gathering techniques, often used by attackers in preparation for some attack. It consists of using tools to learn as much as possible about the composition, configuration, and security mechanisms of the targeted application, system or network. Information that might be collected during a footprinting effort could include open ports, applications and their versions, network topology, and similar information. While footprinting is not intended to be damaging (although certain activities, such as network scans, can sometimes cause disruptions to vulnerable applications inadvertently) it may often pave the way for more damaging attacks."
            },
            {
                "id": "22",
                "name": "Exploiting Trust in Client",
                "prerequisites": "Server software must rely on client side formatted and validated values, and not reinforce these checks on the server side.",
                "related_weakness": [
                    "20",
                    "200",
                    "287",
                    "290",
                    "693"
                ],
                "solutions": "Design: Ensure that client process and/or message is authenticated so that anonymous communications and/or messages are not accepted by the system. Design: Do not rely on client validation or encoding for security purposes. Design: Utilize digital signatures to increase authentication assurance. Design: Utilize two factor authentication to increase authentication assurance. Implementation: Perform input validation for all remote content.",
                "summary": "An attack of this type exploits vulnerabilities in client/server communication channel authentication and data integrity. It leverages the implicit trust a server places in the client, or more importantly, that which the server believes is the client. An attacker executes this type of attack by communicating directly with the server where the server believes it is communicating only with a valid client. There are numerous variations of this type of attack."
            },
            {
                "id": "287",
                "name": "TCP SYN Scan",
                "prerequisites": "This scan type is not possible with some operating systems (Windows XP SP 2). On Linux and Unix systems it requires root privileges to use raw sockets.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary uses a SYN scan to determine the status of ports on the remote target. SYN scanning is the most common type of port scanning that is used because of its enormous advantages and few drawbacks. As a result, novice attackers tend to overly rely on the SYN scan while performing system reconnaissance. As a scanning method, the primary advantages of SYN scanning are its universality and speed. RFC 793 defines the required behavior of any TCP/IP device in that an incoming connection request begins with a SYN packet, which in turn must be followed by a SYN/ACK packet from the receiving service. For this reason, like TCP Connect scanning, SYN scanning works against any TCP stack. Unlike TCP Connect scanning, it is possible to scan thousands of ports per second using this method. This type of scanning is usually referred to as 'half-open' scanning because it does not complete the three-way handshake. The scanning rate is extremely fast because no time is wasted completing the handshake or tearing down the connection. TCP SYN scanning can also immediately detect 3 of the 4 important types of port status: open, closed, and filtered. When a SYN is sent to an open port and unfiltered port, a SYN/ACK will be generated. This technique allows an attacker to scan through stateful firewalls due to the common configuration that TCP SYN segments for a new connection will be allowed for almost any port. When a SYN packet is sent to a closed port a RST is generated, indicating the port is closed. When SYN scanning to a particular port generates no response, or when the request triggers ICMP Type 3 unreachable errors, the port is filtered. A TCP Connect scan has the following characteristics:"
            },
            {
                "id": "293",
                "name": "Traceroute Route Enumeration",
                "prerequisites": "A network capable of routing the attackers' packets to the destination network.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary uses a traceroute utility to map out the route which data flows through the network in route to a target destination. Tracerouting can allow the adversary to construct a working topology of systems and routers by listing the systems through which data passes through on their way to the targeted machine. This attack can return varied results depending upon the type of traceroute that is performed. Traceroute works by sending packets to a target while incrementing the Time-to-Live field in the packet header. As the packet traverses each hop along its way to the destination, its TTL expires generating an ICMP diagnostic message that identifies where the packet expired. Traditional techniques for tracerouting involved the use of ICMP and UDP, but as more firewalls began to filter ingress ICMP, methods of traceroute using TCP were developed."
            },
            {
                "id": "308",
                "name": "UDP Scan",
                "prerequisites": "The ability to send UDP datagrams to a host and receive ICMP error messages from that host. In cases where particular types of ICMP messaging is disallowed, the reliability of UDP scanning drops off sharply.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Firewalls or ACLs which block egress ICMP error types effectively prevent UDP scans from returning any useful information. UDP scanning is complicated by rate limiting mechanisms governing ICMP error messages.",
                "summary": "An adversary engages in UDP scanning to gather information about UDP port status on the target system. UDP scanning methods involve sending a UDP datagram to the target port and looking for evidence that the port is closed. Open UDP ports usually do not respond to UDP datagrams as there is no stateful mechanism within the protocol that requires building or establishing a session. Responses to UDP datagrams are therefore application specific and cannot be relied upon as a method of detecting an open port. UDP scanning relies heavily upon ICMP diagnostic messages in order to determine the status of a remote port. During a UDP scan, a datagram is sent to a target port. If an 'ICMP Type 3 Port unreachable' error message is returned then the port is considered closed. Different types of ICMP messages can indicate a filtered port. UDP scanning is slower than TCP scanning. The protocol characteristics of UDP make port scanning inherently more difficult than with TCP, as well as dependent upon ICMP for accurate scanning. Due to ambiguities that can arise between open ports and filtered ports, UDP scanning results often require a high degree of interpretation and further testing to refine. In general, UDP scanning results are less reliable or accurate than TCP-based scanning."
            },
            {
                "id": "329",
                "name": "ICMP Error Message Quoting Probe",
                "prerequisites": "The ability to monitor and interact with network communications.Access to at least one host, and the privileges to interface with the network interface card.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "",
                "summary": "An adversary uses a technique to generate an ICMP Error message (Port Unreachable, Destination Unreachable, Redirect, Source Quench, Time Exceeded, Parameter Problem) from a target and then analyze the amount of data returned or \"Quoted\" from the originating request that generated the ICMP error message. For this purpose \"Port Unreachable\" error messages are often used, as generating them requires the attacker to send a UDP datagram to a closed port on the target. The goal of this analysis to make inferences about the type of operating system or firmware that sent the error message in reply. This is useful for identifying unique characteristics of operating systems because the RFC-1122 expected behavior reads: \"Every ICMP error message includes the Internet header and at least the first 8 data octets of the datagram that triggered the error; more than 8 octets MAY be sent [...].\" This contrasts with RFC-792 expected behavior, which limited the quoted text to 64 bits (8 octets). Given the latitude in the specification the resulting RFC-1122 stack implementations often respond with a high degree of variability in the amount of data quoted in the error message because \"older\" or \"legacy\" stacks may comply with the RFC-792 specification, while other stacks may choose a longer format in accordance with RFC-1122. As a general rule most operating systems or firmware will quote the first 8 bytes of the datagram triggering the error, but some IP stacks will quote more than the first 8 bytes of data."
            },
            {
                "id": "576",
                "name": "Group Permission Footprinting",
                "prerequisites": "The adversary must have gained access to the target system via physical or logical means in order to carry out this attack.",
                "related_weakness": [
                    "200"
                ],
                "solutions": "Identify programs (such as \"net\") that may be used to enumerate local group permissions and block them by using a software restriction Policy or tools that restrict program execution by process whitelisting.",
                "summary": "An adversary exploits functionality meant to identify information about user groups and their permissions on the target system to an authorized user. By knowing what users/permissions are registered on the target system, the adversary can inform further and more targeted malicious behavior. An example Windows command which can list local groups is \"net localgroup\"."
            },
            {
                "id": "60",
                "name": "Reusing Session IDs (aka Session Replay)",
                "prerequisites": "The target host uses session IDs to keep track of the users. Session IDs are used to control access to resources. The session IDs used by the target host are not well protected from session theft.",
                "related_weakness": [
                    "200",
                    "285",
                    "290",
                    "294",
                    "346",
                    "384",
                    "488",
                    "539",
                    "664",
                    "732"
                ],
                "solutions": "Always invalidate a session ID after the user logout. Setup a session time out for the session IDs. Protect the communication between the client and server. For instance it is best practice to use SSL to mitigate man in the middle attack. Do not code send session ID with GET method, otherwise the session ID will be copied to the URL. In general avoid writing session IDs in the URLs. URLs can get logged in log files, which are vulnerable to an attacker. Encrypt the session data associated with the session ID. Use multifactor authentication.",
                "summary": "This attack targets the reuse of valid session ID to spoof the target system in order to gain privileges. The attacker tries to reuse a stolen session ID used previously during a transaction to perform spoofing and session hijacking. Another name for this type of attack is Session Replay."
            }
        ],
        "cvss": 5.0,
        "cvss-time": "2021-09-29T21:13:00",
        "cvss-vector": "AV:N/AC:L/Au:N/C:P/I:N/A:N",
        "cwe": "CWE-200",
        "id": "CVE-2021-41584",
        "impact": {
            "availability": "NONE",
            "confidentiality": "PARTIAL",
            "integrity": "NONE"
        },
        "last-modified": "2021-09-29T21:13:00",
        "references": [
            "https://security.gradle.com/advisory/2021-02"
        ],
        "summary": "Gradle Enterprise before 2021.1.3 can allow unauthorized viewing of a response (information disclosure of possibly sensitive build/configuration details) via a crafted HTTP request with the X-Gradle-Enterprise-Ajax-Request header.",
        "vulnerable_configuration": [
            "cpe:2.3:a:gradle:gradle:*:*:*:*:enterprise:*:*:*"
        ],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": [
            "cpe:2.3:a:gradle:gradle:*:*:*:*:enterprise:*:*:*"
        ]
    },
    {
        "Modified": "2021-09-29T21:07:00",
        "Published": "2021-09-22T09:15:00",
        "access": {
            "authentication": "NONE",
            "complexity": "MEDIUM",
            "vector": "NETWORK"
        },
        "assigner": "security@apache.org",
        "capec": [],
        "cvss": 4.3,
        "cvss-time": "2021-09-29T21:07:00",
        "cvss-vector": "AV:N/AC:M/Au:N/C:P/I:N/A:N",
        "cwe": "CWE-203",
        "id": "CVE-2021-38153",
        "impact": {
            "availability": "NONE",
            "confidentiality": "PARTIAL",
            "integrity": "NONE"
        },
        "last-modified": "2021-09-29T21:07:00",
        "references": [
            "https://kafka.apache.org/cve-list"
        ],
        "summary": "Some components in Apache Kafka use `Arrays.equals` to validate a password or key, which is vulnerable to timing attacks that make brute force attacks for such credentials more likely to be successful. Users should upgrade to 2.8.1 or higher, or 3.0.0 or higher where this vulnerability has been fixed. The affected versions include Apache Kafka 2.0.0, 2.0.1, 2.1.0, 2.1.1, 2.2.0, 2.2.1, 2.2.2, 2.3.0, 2.3.1, 2.4.0, 2.4.1, 2.5.0, 2.5.1, 2.6.0, 2.6.1, 2.6.2, 2.7.0, 2.7.1, and 2.8.0.",
        "vulnerable_configuration": [
            "cpe:2.3:a:apache:kafka:2.0.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.0.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.0.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.1.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.1.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.1.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.2.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.2.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.2.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.3.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.3.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.6.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.6.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.6.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.7.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.7.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.8.0:*:*:*:*:*:*:*"
        ],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": [
            "cpe:2.3:a:apache:kafka:2.0.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.0.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.0.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.1.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.1.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.1.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.2.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.2.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.2.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.3.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.3.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.6.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.6.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.6.2:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.7.0:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.7.1:*:*:*:*:*:*:*",
            "cpe:2.3:a:apache:kafka:2.8.0:*:*:*:*:*:*:*"
        ]
    },
    {
        "Modified": "2021-09-29T21:06:00",
        "Published": "2021-09-16T22:15:00",
        "access": {
            "authentication": "NONE",
            "complexity": "LOW",
            "vector": "ADJACENT_NETWORK"
        },
        "assigner": "cve@mitre.org",
        "capec": [
            {
                "id": "94",
                "name": "Man in the Middle Attack",
                "prerequisites": "There are two components communicating with each other. An attacker is able to identify the nature and mechanism of communication between the two target components. An attacker can eavesdrop on the communication between the target components. Strong mutual authentication is not used between the two target components yielding opportunity for attacker interposition. The communication occurs in clear (not encrypted) or with insufficient and spoofable encryption.",
                "related_weakness": [
                    "287",
                    "290",
                    "294",
                    "300",
                    "593",
                    "724"
                ],
                "solutions": "Get your Public Key signed by a Certificate Authority Encrypt your communication using cryptography (SSL,...) Use Strong mutual authentication to always fully authenticate both ends of any communications channel. Exchange public keys using a secure channel",
                "summary": "This type of attack targets the communication between two components (typically client and server). The attacker places himself in the communication channel between the two components. Whenever one component attempts to communicate with the other (data flow, authentication challenges, etc.), the data first goes to the attacker, who has the opportunity to observe or alter it, and it is then passed on to the other component as if it was never observed. This interposition is transparent leaving the two compromised components unaware of the potential corruption or leakage of their communications. The potential for Man-in-the-Middle attacks yields an implicit lack of trust in communication or identify between two components. MITM attacks differ from sniffing attacks since they often modify the communications prior to delivering it to the intended recipient. These attacks also differ from interception attacks since they may forward the sender's original unmodified data, after copying it, instead of keeping it for themselves."
            },
            {
                "id": "57",
                "name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
                "prerequisites": "Opportunity to intercept must exist beyond the point where SSL is terminated. The attacker must be able to insert a listener actively (proxying the communication) or passively (sniffing the communication) in the client-server communication path.",
                "related_weakness": [
                    "287",
                    "300",
                    "693",
                    "724"
                ],
                "solutions": "Implementation: Implement message level security such as HMAC in the HTTP communication Design: Utilize defense in depth, do not rely on a single security mechanism like SSL Design: Enforce principle of least privilege",
                "summary": "This attack utilizes a REST(REpresentational State Transfer)-style applications' trust in the system resources and environment to obtain sensitive data once SSL is terminated. Rest applications premise is that they leverage existing infrastructure to deliver web services functionality. An example of this is a Rest application that uses HTTP Get methods and receives a HTTP response with an XML document. These Rest style web services are deployed on existing infrastructure such as Apache and IIS web servers with no SOAP stack required. Unfortunately from a security standpoint, there frequently is no interoperable identity security mechanism deployed, so Rest developers often fall back to SSL to deliver security. In large data centers, SSL is typically terminated at the edge of the network - at the firewall, load balancer, or router. Once the SSL is terminated the HTTP request is in the clear (unless developers have hashed or encrypted the values, but this is rare). The attacker can utilize a sniffer such as Wireshark to snapshot the credentials, such as username and password that are passed in the clear once SSL is terminated. Once the attacker gathers these credentials, they can submit requests to the web service provider just as authorized user do. There is not typically an authentication on the client side, beyond what is passed in the request itself so once this is compromised, then this is generally sufficient to compromise the service's authentication scheme."
            },
            {
                "id": "593",
                "name": "Session Hijacking",
                "prerequisites": "An application that leverages sessions to perform authentication.",
                "related_weakness": [
                    "287"
                ],
                "solutions": "Properly encrypt and sign identity tokens in transit, and use industry standard session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf. Utilize a session timeout for all sessions. If the user does not explicitly logout, terminate their session after this period of inactivity. If the user logs back in then a new session key should be generated.",
                "summary": "This type of attack involves an adversary that exploits weaknesses in an application's use of sessions in performing authentication. The advarsary is able to steal or manipulate an active session and use it to gain unathorized access to the application."
            },
            {
                "id": "194",
                "name": "Fake the Source of Data",
                "prerequisites": "This attack is only applicable when a vulnerable entity associates data or services with an identity. Without such an association, there would be no reason to fake the source.",
                "related_weakness": [
                    "287"
                ],
                "solutions": "",
                "summary": "An adversary takes advantage of improper authentication to provide data or services under a falsified identity. The purpose of using the falsified identity may be to prevent traceability of the provided data or to assume the rights granted to another individual. One of the simplest forms of this attack would be the creation of an email message with a modified \"From\" field in order to appear that the message was sent from someone other than the actual sender. The root of the attack (in this case the email system) fails to properly authenticate the source and this results in the reader incorrectly performing the instructed action. Results of the attack vary depending on the details of the attack, but common results include privilege escalation, obfuscation of other attacks, and data corruption/manipulation."
            },
            {
                "id": "114",
                "name": "Authentication Abuse",
                "prerequisites": "An authentication mechanism or subsystem implementing some form of authentication such as passwords, digest authentication, security certificates, etc. which is flawed in some way.",
                "related_weakness": [
                    "287"
                ],
                "solutions": "",
                "summary": "An attacker obtains unauthorized access to an application, service or device either through knowledge of the inherent weaknesses of an authentication mechanism, or by exploiting a flaw in the authentication scheme's implementation. In such an attack an authentication mechanism is functioning but a carefully controlled sequence of events causes the mechanism to grant access to the attacker. This attack may exploit assumptions made by the target's authentication procedures, such as assumptions regarding trust relationships or assumptions regarding the generation of secret values. This attack differs from Authentication Bypass attacks in that Authentication Abuse allows the attacker to be certified as a valid user through illegitimate means, while Authentication Bypass allows the user to access protected material without ever being certified as an authenticated user. This attack does not rely on prior sessions established by successfully authenticating users, as relied upon for the \"Exploitation of Session Variables, Resource IDs and other Trusted Credentials\" attack patterns."
            },
            {
                "id": "151",
                "name": "Identity Spoofing",
                "prerequisites": "The identity associated with the message or resource must be removable or modifiable in an undetectable way.",
                "related_weakness": [
                    "287"
                ],
                "solutions": "Employ robust authentication processes (e.g., multi-factor authentication).",
                "summary": "Identity Spoofing refers to the action of assuming (i.e., taking on) the identity of some other entity (human or non-human) and then using that identity to accomplish a goal. An adversary may craft messages that appear to come from a different principle or use stolen / spoofed authentication credentials. Alternatively, an adversary may intercept a message from a legitimate sender and attempt to make it look like the message comes from them without changing its content. The latter form of this attack can be used to hijack credentials from legitimate users. Identity Spoofing attacks need not be limited to transmitted messages - any resource that is associated with an identity (for example, a file with a signature) can be the target of an attack where the adversary attempts to change the apparent identity. This attack differs from Content Spoofing attacks where the adversary does not wish to change the apparent identity of the message but instead wishes to change what the message says. In an Identity Spoofing attack, the adversary is attempting to change the identity of the content."
            },
            {
                "id": "633",
                "name": "Token Impersonation",
                "prerequisites": "This pattern of attack is only applicable when a downstream user leverages tokens to verify identity, and then takes action based on that identity.",
                "related_weakness": [
                    "287"
                ],
                "solutions": "",
                "summary": "An adversary exploits a weakness in authentication to create an access token (or equivalent) that impersonates a different entity, and then associates a process/thread to that that impersonated token. This action causes a downstream user to make a decision or take action that is based on the assumed identity, and not the response that blocks the adversary."
            },
            {
                "id": "115",
                "name": "Authentication Bypass",
                "prerequisites": "An authentication mechanism or subsystem implementing some form of authentication such as passwords, digest authentication, security certificates, etc.",
                "related_weakness": [
                    "287"
                ],
                "solutions": "",
                "summary": "An attacker gains access to application, service, or device with the privileges of an authorized or privileged user by evading or circumventing an authentication mechanism. The attacker is therefore able to access protected data without authentication ever having taken place. This refers to an attacker gaining access equivalent to an authenticated user without ever going through an authentication procedure. This is usually the result of the attacker using an unexpected access procedure that does not go through the proper checkpoints where authentication should occur. For example, a web site might assume that all users will click through a given link in order to get to secure material and simply authenticate everyone that clicks the link. However, an attacker might be able to reach secured web content by explicitly entering the path to the content rather than clicking through the authentication link, thereby avoiding the check entirely. This attack pattern differs from other authentication attacks in that attacks of this pattern avoid authentication entirely, rather than faking authentication by exploiting flaws or by stealing credentials from legitimate users."
            },
            {
                "id": "22",
                "name": "Exploiting Trust in Client",
                "prerequisites": "Server software must rely on client side formatted and validated values, and not reinforce these checks on the server side.",
                "related_weakness": [
                    "20",
                    "200",
                    "287",
                    "290",
                    "693"
                ],
                "solutions": "Design: Ensure that client process and/or message is authenticated so that anonymous communications and/or messages are not accepted by the system. Design: Do not rely on client validation or encoding for security purposes. Design: Utilize digital signatures to increase authentication assurance. Design: Utilize two factor authentication to increase authentication assurance. Implementation: Perform input validation for all remote content.",
                "summary": "An attack of this type exploits vulnerabilities in client/server communication channel authentication and data integrity. It leverages the implicit trust a server places in the client, or more importantly, that which the server believes is the client. An attacker executes this type of attack by communicating directly with the server where the server believes it is communicating only with a valid client. There are numerous variations of this type of attack."
            },
            {
                "id": "650",
                "name": "Upload a Web Shell to a Web Server",
                "prerequisites": "The web server is susceptible to one of the various web application exploits that allows for uploading a shell file.",
                "related_weakness": [
                    "287",
                    "553"
                ],
                "solutions": "Insure that the file permissions in directories on the web server from which files can be execute is set to the \"least privilege\" settings, and that those directories contents is controlled by a whitelist.",
                "summary": "By exploiting insufficient permissions, it is possible to upload a web shell to a web server in such a way that it can be executed remotely. This shell can have various capabilities, thereby acting as a \"gateway\" to the underlying web server. The shell might execute at the higher permission level of the web server, providing the ability the execute malicious code at elevated levels."
            }
        ],
        "cvss": 8.3,
        "cvss-time": "2021-09-29T21:06:00",
        "cvss-vector": "AV:A/AC:L/Au:N/C:C/I:C/A:C",
        "cwe": "CWE-287",
        "id": "CVE-2021-41314",
        "impact": {
            "availability": "COMPLETE",
            "confidentiality": "COMPLETE",
            "integrity": "COMPLETE"
        },
        "last-modified": "2021-09-29T21:06:00",
        "references": [
            "https://gynvael.coldwind.pl/?id=742",
            "https://kb.netgear.com/000063978/Security-Advisory-for-Multiple-Vulnerabilities-on-Some-Smart-Switches-PSV-2021-0140-PSV-2021-0144-PSV-2021-0145"
        ],
        "summary": "Certain NETGEAR smart switches are affected by a \\n injection in the web UI's password field, which - due to several faulty aspects of the authentication scheme - allows the attacker to create (or overwrite) a file with specific content (e.g., the \"2\" string). This leads to admin session crafting and therefore gaining full web UI admin privileges by an unauthenticated attacker. This affects GC108P before 1.0.8.2, GC108PP before 1.0.8.2, GS108Tv3 before 7.0.7.2, GS110TPP before 7.0.7.2, GS110TPv3 before 7.0.7.2, GS110TUP before 1.0.5.3, GS308T before 1.0.3.2, GS310TP before 1.0.3.2, GS710TUP before 1.0.5.3, GS716TP before 1.0.4.2, GS716TPP before 1.0.4.2, GS724TPP before 2.0.6.3, GS724TPv2 before 2.0.6.3, GS728TPPv2 before 6.0.8.2, GS728TPv2 before 6.0.8.2, GS750E before 1.0.1.10, GS752TPP before 6.0.8.2, GS752TPv2 before 6.0.8.2, MS510TXM before 1.0.4.2, and MS510TXUP before 1.0.4.2.",
        "vulnerable_configuration": [
            "cpe:2.3:o:netgear:gc108p_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gc108p:-:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gc108pp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gc108pp:-:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs108t_firmware:5.4.2.29:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs108t:v3:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs110tpp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs110tpp:-:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs110tp_firmware:5.4.2.29:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs110tp:v3:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs110tup_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs110tup:-:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs308t_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs308t:-:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs310tp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs310tp:-:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs710tup_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs710tup:-:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs716tp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs716tp:-:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs716tpp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs716tpp:-:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs724tpp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs724tpp:-:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs724tp_firmware:1.1.1.29:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs724tp:v2:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs728tpp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs728tpp:v2:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs728tp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs728tp:v2:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs750e_firmware:1.0.1.4:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs750e:-:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs752tpp_firmware:6.0.0.48:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs752tpp:-:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs752tp_firmware:6.0.0.48:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:gs752tp:v2:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:ms510txm_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:ms510txm:-:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:ms510txup_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:h:netgear:ms510txup:-:*:*:*:*:*:*:*"
        ],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": [
            "cpe:2.3:o:netgear:gc108p_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gc108pp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs108t_firmware:5.4.2.29:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs110tpp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs110tp_firmware:5.4.2.29:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs110tup_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs308t_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs310tp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs710tup_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs716tp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs716tpp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs724tpp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs724tp_firmware:1.1.1.29:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs728tpp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs728tp_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs750e_firmware:1.0.1.4:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs752tpp_firmware:6.0.0.48:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:gs752tp_firmware:6.0.0.48:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:ms510txm_firmware:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:netgear:ms510txup_firmware:*:*:*:*:*:*:*:*"
        ]
    },
    {
        "Modified": "2021-09-29T21:02:00",
        "Published": "2021-09-21T17:15:00",
        "access": {
            "authentication": "NONE",
            "complexity": "MEDIUM",
            "vector": "NETWORK"
        },
        "assigner": "report@snyk.io",
        "capec": [
            {
                "id": "591",
                "name": "Reflected XSS",
                "prerequisites": "An application that leverages a client-side web browser with scripting enabled. An application that fail to adequately sanitize or encode untrusted input.",
                "related_weakness": [
                    "79"
                ],
                "solutions": "Use browser technologies that do not allow client-side scripting. Utilize strict type, character, and encoding enforcement. Ensure that all user-supplied input is validated before use.",
                "summary": "This type of attack is a form of Cross-Site Scripting (XSS) where a malicious script is \"reflected\" off a vulnerable web application and then executed by a victim's browser. The process starts with an adversary delivering a malicious script to a victim and convincing the victim to send the script to the vulnerable web application. The most common method of this is through a phishing email where the adversary embeds the malicious script with a URL that the victim then clicks on. In processing the subsequent request, the vulnerable web application incorrectly considers the malicious script as valid input and uses it to creates a reposnse that is then sent back to the victim. To launch a successful Reflected XSS attack, an adversary looks for places where user-input is used directly in the generation of a response. This often involves elements that are not expected to host scripts such as image tags (<img>), or the addition of event attibutes such as onload and onmouseover. These elements are often not subject to the same input validation, output encoding, and other content filtering and checking routines."
            },
            {
                "id": "209",
                "name": "XSS Using MIME Type Mismatch",
                "prerequisites": "The victim must follow a crafted link that references a scripting file that is mis-typed as a non-executable file. The victim's browser must detect the true type of a mis-labeled scripting file and invoke the appropriate script interpreter without first performing filtering on the content.",
                "related_weakness": [
                    "20",
                    "646",
                    "79"
                ],
                "solutions": "",
                "summary": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser."
            },
            {
                "id": "588",
                "name": "DOM-Based XSS",
                "prerequisites": "An application that leverages a client-side web browser with scripting enabled. An application that manipulates the DOM via client-side scripting. An application that failS to adequately sanitize or encode untrusted input.",
                "related_weakness": [
                    "20",
                    "79",
                    "83"
                ],
                "solutions": "Use browser technologies that do not allow client-side scripting. Utilize proper character encoding for all output produced within client-site scripts manipulating the DOM. Ensure that all user-supplied input is validated before use.",
                "summary": "This type of attack is a form of Cross-Site Scripting (XSS) where a malicious script is inserted into the client-side HTML being parsed by a web browser. Content served by a vulnerable web application includes script code used to manipulate the Document Object Model (DOM). This script code either does not properly validate input, or does not perform proper output encoding, thus creating an opportunity for an adversary to inject a malicious script launch a XSS attack. A key distinction between other XSS attacks and DOM-based attacks is that in other XSS attacks, the malicious script runs when the vulnerable web page is initially loaded, while a DOM-based attack executes sometime after the page loads. Another distinction of DOM-based attacks is that in some cases, the malicious script is never sent to the vulnerable web server at all. An attack like this is guaranteed to bypass any server-side filtering attempts to protect users."
            },
            {
                "id": "592",
                "name": "Stored XSS",
                "prerequisites": "An application that leverages a client-side web browser with scripting enabled. An application that fails to adequately sanitize or encode untrusted input. An application that stores information provided by the user in data storage of some kind.",
                "related_weakness": [
                    "79"
                ],
                "solutions": "Use browser technologies that do not allow client-side scripting. Utilize strict type, character, and encoding enforcement. Ensure that all user-supplied input is validated before being stored.",
                "summary": "This type of attack is a form of Cross-site Scripting (XSS) where a malicious script is persistenly \"stored\" within the data storage of a vulnerable web application. Initially presented by an adversary to the vulnerable web application, the malicious script is incorrectly considered valid input and is not properly encoded by the web application. A victim is then convinced to use the web application in a way that creates a response that includes the malicious script. This response is subsequently sent to the victim and the malicious script is executed by the victim's browser. To launch a successful Stored XSS attack, an adversary looks for places where stored input data is used in the generation of a response. This often involves elements that are not expected to host scripts such as image tags (<img>), or the addition of event attibutes such as onload and onmouseover. These elements are often not subject to the same input validation, output encoding, and other content filtering and checking routines."
            },
            {
                "id": "85",
                "name": "AJAX Fingerprinting",
                "prerequisites": "The user must allow JavaScript to execute in their browser",
                "related_weakness": [
                    "113",
                    "116",
                    "184",
                    "20",
                    "348",
                    "692",
                    "712",
                    "79",
                    "86",
                    "96"
                ],
                "solutions": "Design: Use browser technologies that do not allow client side scripting. Design: Utilize strict type, character, and encoding enforcement Implementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification. Implementation: Perform input validation for all remote content. Implementation: Perform output validation for all remote content. Implementation: Disable scripting languages such as JavaScript in browser Implementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.",
                "summary": "This attack utilizes the frequent client-server roundtrips in Ajax conversation to scan a system. While Ajax does not open up new vulnerabilities per se, it does optimize them from an attacker point of view. In many XSS attacks the attacker must get a \"hole in one\" and successfully exploit the vulnerability on the victim side the first time, once the client is redirected the attacker has many chances to engage in follow on probes, but there is only one first chance. In a widely used web application this is not a major problem because 1 in a 1,000 is good enough in a widely used application. A common first step for an attacker is to footprint the environment to understand what attacks will work. Since footprinting relies on enumeration, the conversational pattern of rapid, multiple requests and responses that are typical in Ajax applications enable an attacker to look for many vulnerabilities, well-known ports, network locations and so on."
            },
            {
                "id": "63",
                "name": "Cross-Site Scripting (XSS)",
                "prerequisites": "Target client software must be a client that allows scripting communication from remote hosts, such as a JavaScript-enabled Web Browser.",
                "related_weakness": [
                    "20",
                    "79"
                ],
                "solutions": "Design: Use browser technologies that do not allow client side scripting. Design: Utilize strict type, character, and encoding enforcement Design: Server side developers should not proxy content via XHR or other means, if a http proxy for remote content is setup on the server side, the client's browser has no way of discerning where the data is originating from. Implementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification. Implementation: Perform input validation for all remote content. Implementation: Perform output validation for all remote content. Implementation: Session tokens for specific host Implementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.",
                "summary": "An adversary embeds malicious scripts in content that will be served to web browsers. The goal of the attack is for the target software, the client-side browser, to execute the script with the users' privilege level. An attack of this type exploits a programs' vulnerabilities that are brought on by allowing remote hosts to execute code and scripts. Web browsers, for example, have some simple security controls in place, but if a remote attacker is allowed to execute scripts (through injecting them in to user-generated content like bulletin boards) then these controls may be bypassed. Further, these attacks are very difficult for an end user to detect."
            }
        ],
        "cvss": 5.8,
        "cvss-time": "2021-09-29T21:02:00",
        "cvss-vector": "AV:N/AC:M/Au:N/C:P/I:P/A:N",
        "cwe": "CWE-79",
        "id": "CVE-2021-23443",
        "impact": {
            "availability": "NONE",
            "confidentiality": "PARTIAL",
            "integrity": "PARTIAL"
        },
        "last-modified": "2021-09-29T21:02:00",
        "references": [
            "https://snyk.io/vuln/SNYK-JS-EDGEJS-1579556",
            "https://github.com/edge-js/edge/commit/fa2c7fde86327aeae232752e89a6e37e2e469e21"
        ],
        "summary": "This affects the package edge.js before 5.3.2. A type confusion vulnerability can be used to bypass input sanitization when the input to be rendered is an array (instead of a string or a SafeValue), even if {{ }} are used.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T20:55:00",
        "Published": "2021-09-29T20:15:00",
        "access": {},
        "assigner": "ics-cert@hq.dhs.gov",
        "capec": [
            {
                "id": "546",
                "name": "Probe Application Memory",
                "prerequisites": "The cloud provider must not assuredly delete part or all of the sensitive data for which they are responsible.The adversary must have the ability to interact with the system.",
                "related_weakness": [
                    "284"
                ],
                "solutions": "Cloud providers should completely delete data to render it irrecoverable and inaccessible from any layer and component of infrastructure resources. Deletion of data should be completed promptly when requested.",
                "summary": "An adversary obtains unauthorized information due to insecure or incomplete data deletion in a multi-tenant environment. If a cloud provider fails to completely delete storage and data from former cloud tenants' systems/resources, once these resources are allocated to new, potentially malicious tenants, the latter can probe the provided resources for sensitive information still there."
            },
            {
                "id": "502",
                "name": "Intent Spoof",
                "prerequisites": "An adversary must be able install a purpose built malicious application onto the Android device and convince the user to execute it. The malicious application will be used to issue spoofed intents.",
                "related_weakness": [
                    "284"
                ],
                "solutions": "To limit one's exposure to this type of attack, developers should avoid exporting components unless the component is specifically designed to handle requests from untrusted applications. Developers should be aware that declaring an intent filter will automatically export the component, exposing it to public access. Critical, state-changing actions should not be placed in exported components. If a single component handles both inter- and intra-application requests, the developer should consider dividing that component into separate components. If a component must be exported (e.g., to receive system broadcasts), then the component should dynamically check the caller's identity prior to performing any operations. Requiring Signature or SignatureOrSystem permissions is an effective way of limiting a component's exposure to a set of trusted applications. Finally, the return values of exported components can also leak private data, so developers should check the caller's identity prior to returning sensitive values.",
                "summary": "An adversary, through a previously installed malicious application, issues an intent directed toward a specific trusted application's component in an attempt to achieve a variety of different objectives including modification of data, information disclosure, and data injection. Components that have been unintentionally exported and made public are subject to this type of an attack. If the component blindly trusts the intent's action, then the target application performs the functionality at the adversary's request, helping the adversary achieve the desired negative technical impact."
            },
            {
                "id": "552",
                "name": "Install Rootkit ",
                "prerequisites": "",
                "related_weakness": [
                    "284"
                ],
                "solutions": "Prevent adversary access to privileged accounts necessary to install rootkits.",
                "summary": "An adversary exploits a weakness in authentication to install malware that alters the functionality and information provide by targeted operating system API calls. Often referred to as rootkits, it is often used to hide the presence of programs, files, network connections, services, drivers, and other system components."
            },
            {
                "id": "562",
                "name": "Modify Shared File",
                "prerequisites": "",
                "related_weakness": [
                    "284"
                ],
                "solutions": "Disallow shared content. Protect shared folders by minimizing users that have write access. Use utilities that mitigate exploitation like the Microsoft Enhanced Mitigation Experience Toolkit (EMET) to prevent exploits from being run.",
                "summary": "An adversary manipulates the files in a shared location by adding malicious programs, scripts, or exploit code to valid content. Once a user opens the shared content, the tainted content is executed."
            },
            {
                "id": "558",
                "name": "Replace Trusted Executable",
                "prerequisites": "",
                "related_weakness": [
                    "284"
                ],
                "solutions": "",
                "summary": "An adversary exploits weaknesses in privilege management or access control to replace a trusted executable with a malicious version and enable the execution of malware when that trusted executable is called."
            },
            {
                "id": "550",
                "name": "Install New Service",
                "prerequisites": "",
                "related_weakness": [
                    "284"
                ],
                "solutions": "Limit privileges of user accounts so new service creation can only be performed by authorized administrators.",
                "summary": "When an operating system starts, it also starts programs called services or daemons. Adversaries may install a new service which will be executed at startup (on a Windows system, by modifying the registry). The service name may be disguised by using a name from a related operating system or benign software. Services are usually run with elevated privileges."
            },
            {
                "id": "19",
                "name": "Embedding Scripts within Scripts",
                "prerequisites": "Target software must be able to execute scripts, and also grant the adversary privilege to write/upload scripts.",
                "related_weakness": [
                    "284"
                ],
                "solutions": "Use browser technologies that do not allow client side scripting. Utilize strict type, character, and encoding enforcement. Server side developers should not proxy content via XHR or other means. If a HTTP proxy for remote content is setup on the server side, the client's browser has no way of discerning where the data is originating from. Ensure all content that is delivered to client is sanitized against an acceptable content specification. Perform input validation for all remote content. Perform output validation for all remote content. Disable scripting languages such as JavaScript in browser Session tokens for specific host Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this. Privileges are constrained, if a script is loaded, ensure system runs in chroot jail or other limited authority mode",
                "summary": "An attack of this type exploits a programs' vulnerabilities that are brought on by allowing remote hosts to execute scripts. The adversary leverages this capability to execute his/her own script by embedding it within other scripts that the target software is likely to execute. The adversary must have the ability to inject their script into a script that is likely to be executed. If this is done, then the adversary can potentially launch a variety of probes and attacks against the web server's local environment, in many cases the so-called DMZ, back end resources the web server can communicate with, and other hosts. With the proliferation of intermediaries, such as Web App Firewalls, network devices, and even printers having JVMs and Web servers, there are many locales where an attacker can inject malicious scripts. Since this attack pattern defines scripts within scripts, there are likely privileges to execute said attack on the host. These attacks are not solely limited to the server side, client side scripts like Ajax and client side JavaScript can contain malicious scripts as well."
            },
            {
                "id": "441",
                "name": "Malicious Logic Insertion",
                "prerequisites": "Access to the component currently deployed at a victim location.",
                "related_weakness": [
                    "284"
                ],
                "solutions": "",
                "summary": "An adversary installs or adds malicious logic (also known as malware) into a seemingly benign component of a fielded system. This logic is often hidden from the user of the system and works behind the scenes to achieve negative impacts. With the proliferation of mass digital storage and inexpensive multimedia devices, Bluetooth and 802.11 support, new attack vectors for spreading malware are emerging for things we once thought of as innocuous greeting cards, picture frames, or digital projectors. This pattern of attack focuses on systems already fielded and used in operation as opposed to systems and their components that are still under development and part of the supply chain."
            },
            {
                "id": "551",
                "name": "Modify Existing Service",
                "prerequisites": "",
                "related_weakness": [
                    "284",
                    "522"
                ],
                "solutions": "Limit privileges of user accounts so service changes can only be performed by authorized administrators. Also monitor any service changes that may occur inadvertently.",
                "summary": "When an operating system starts, it also starts programs called services or daemons. Modifying existing services may break existing services or may enable services that are disabled/not commonly used."
            },
            {
                "id": "478",
                "name": "Modification of Windows Service Configuration",
                "prerequisites": "The adversary must have the capability to write to the Windows Registry on the targeted system.",
                "related_weakness": [
                    "284"
                ],
                "solutions": "Ensure proper permissions are set for Registry hives to prevent users from modifying keys for system components that may lead to privilege escalation.",
                "summary": "An adversary exploits a weakness in access control to modify the execution parameters of a Windows service. Specifically, if the permissions for users and groups are not properly assigned and allow access to the registry keys used to store the configuration information for a service, then an adversary could change settings defining the path to the executable and cause a malicious binary to be executed."
            },
            {
                "id": "536",
                "name": "Data Injected During Configuration",
                "prerequisites": "The attacker must have previously compromised the victim's systems or have physical access to the victim's systems. Advanced knowledge of software and hardware capabilities of a manufacturer's product.",
                "related_weakness": [
                    "284"
                ],
                "solutions": "Ensure that proper access control is implemented on all systems to prevent unauthorized access to system files and processes.",
                "summary": "An attacker with access to data files and processes on a victim's system injects malicious data into critical operational data during configuration or recalibration, causing the victim's system to perform in a suboptimal manner that benefits the adversary."
            },
            {
                "id": "564",
                "name": "Run Software at Logon",
                "prerequisites": "",
                "related_weakness": [
                    "284"
                ],
                "solutions": "Restrict write access to logon scripts to necessary administrators.",
                "summary": "Operating system allows logon scripts to be run whenever a specific user or users logon to a system. If adversaries can access these scripts, they may insert additional code into the logon script. This code can allow them to maintain persistence or move laterally within an enclave because it is executed every time the affected user or users logon to a computer. Modifying logon scripts can effectively bypass workstation and enclave firewalls. Depending on the access configuration of the logon scripts, either local credentials or a remote administrative account may be necessary."
            },
            {
                "id": "578",
                "name": "Disable Security Software",
                "prerequisites": "The adversary must have the capability to interact with the configuration of the targeted system.",
                "related_weakness": [
                    "284"
                ],
                "solutions": "Ensure proper permissions are in place to prevent adversaries from altering the execution status of security tools.",
                "summary": "An adversary exploits a weakness in access control to disable security tools so that detection does not occur. This can take the form of killing processes, deleting registry keys so that tools do not start at run time, deleting log files, or other methods."
            },
            {
                "id": "563",
                "name": "Add Malicious File to Shared Webroot",
                "prerequisites": "",
                "related_weakness": [
                    "284"
                ],
                "solutions": "Ensure proper permissions on directories that are accessible through a web server. Disallow remote access to the web root. Disable execution on directories within the web root. Ensure that permissions of the web server process are only what is required by not using built-in accounts and instead create specific accounts to limit unnecessary access or permissions overlap across multiple systems.",
                "summary": "An adversaries may add malicious content to a website through the open file share and then browse to that content with a web browser to cause the server to execute the content. The malicious content will typically run under the context and permissions of the web server process, often resulting in local system or administrative privileges depending on how the web server is configured."
            },
            {
                "id": "479",
                "name": "Malicious Root Certificate",
                "prerequisites": "The adversary must have the ability to create a new root certificate.",
                "related_weakness": [
                    "284"
                ],
                "solutions": "",
                "summary": "An adversary exploits a weakness in authorization and installs a new root certificate on a compromised system. Certificates are commonly used for establishing secure TLS/SSL communications within a web browser. When a user attempts to browse a website that presents a certificate that is not trusted an error message will be displayed to warn the user of the security risk. Depending on the security settings, the browser may not allow the user to establish a connection to the website. Adversaries have used this technique to avoid security warnings prompting users when compromised systems connect over HTTPS to adversary controlled web servers that spoof legitimate websites in order to collect login credentials."
            },
            {
                "id": "503",
                "name": "WebView Exposure",
                "prerequisites": "This type of an attack requires the adversary to convince the user to load the malicious web page inside the target application. Once loaded, the malicious web page will have the same permissions as the target application and will have access to all registered interfaces. Both the permission and the interface must be in place for the functionality to be exposed.",
                "related_weakness": [
                    "284"
                ],
                "solutions": "To mitigate this type of an attack, an application should limit permissions to only those required and should verify the origin of all web content it loads.",
                "summary": "An adversary, through a malicious web page, accesses application specific functionality by leveraging interfaces registered through WebView's addJavascriptInterface API. Once an interface is registered to WebView through addJavascriptInterface, it becomes global and all pages loaded in the WebView can call this interface."
            },
            {
                "id": "556",
                "name": "Replace File Extension Handlers",
                "prerequisites": "",
                "related_weakness": [
                    "284"
                ],
                "solutions": "Inspect registry for changes. Limit privileges of user accounts so changes to default file handlers can only be performed by authorized administrators.",
                "summary": "When a file is opened, its file handler is checked to determine which program opens the file. File handlers are configuration properties of many operating systems. Applications can modify the file handler for a given file extension to call an arbitrary program when a file with the given extension is opened."
            }
        ],
        "cvss": null,
        "cwe": "CWE-284",
        "id": "CVE-2020-12030",
        "impact": {},
        "last-modified": "2021-09-29T20:55:00",
        "references": [
            "https://us-cert.cisa.gov/ics/advisories/icsa-20-135-02"
        ],
        "summary": "There is a flaw in the code used to configure the internal gateway firewall when the gateway's VLAN feature is enabled. If a user enables the VLAN setting, the internal gateway firewall becomes disabled resulting in exposure of all ports used by the gateway.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T20:55:00",
        "Published": "2021-09-29T20:15:00",
        "access": {},
        "assigner": "cve-assignments@hackerone.com",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-22946",
        "impact": {},
        "last-modified": "2021-09-29T20:55:00",
        "references": [
            "https://hackerone.com/reports/1334111"
        ],
        "summary": "A user can tell curl >= 7.20.0 and <= 7.78.0 to require a successful upgrade to TLS when speaking to an IMAP, POP3 or FTP server (`--ssl-reqd` on the command line or`CURLOPT_USE_SSL` set to `CURLUSESSL_CONTROL` or `CURLUSESSL_ALL` withlibcurl). This requirement could be bypassed if the server would return a properly crafted but perfectly legitimate response.This flaw would then make curl silently continue its operations **withoutTLS** contrary to the instructions and expectations, exposing possibly sensitive data in clear text over the network.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T20:55:00",
        "Published": "2021-09-29T20:15:00",
        "access": {},
        "assigner": "cve-assignments@hackerone.com",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-22947",
        "impact": {},
        "last-modified": "2021-09-29T20:55:00",
        "references": [
            "https://hackerone.com/reports/1334763"
        ],
        "summary": "When curl >= 7.20.0 and <= 7.78.0 connects to an IMAP or POP3 server to retrieve data using STARTTLS to upgrade to TLS security, the server can respond and send back multiple responses at once that curl caches. curl would then upgrade to TLS but not flush the in-queue of cached responses but instead continue using and trustingthe responses it got *before* the TLS handshake as if they were authenticated.Using this flaw, it allows a Man-In-The-Middle attacker to first inject the fake responses, then pass-through the TLS traffic from the legitimate server and trick curl into sending data back to the user thinking the attacker's injected data comes from the TLS-protected server.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T20:55:00",
        "Published": "2021-09-29T20:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-35943",
        "impact": {},
        "last-modified": "2021-09-29T20:55:00",
        "references": [
            "https://www.couchbase.com/alerts",
            "https://docs.couchbase.com/server/current/release-notes/relnotes.html"
        ],
        "summary": "Couchbase Server 6.5.x and 6.6.x through 6.6.2 has Incorrect Access Control. Externally managed users are not prevented from using an empty password, per RFC4513.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T20:55:00",
        "Published": "2021-09-29T20:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-35944",
        "impact": {},
        "last-modified": "2021-09-29T20:55:00",
        "references": [
            "https://www.couchbase.com/alerts",
            "https://docs.couchbase.com/server/current/release-notes/relnotes.html"
        ],
        "summary": "Couchbase Server 6.5.x, 6.6.x through 6.6.2, and 7.0.0 has a Buffer Overflow. A specially crafted network packet sent from an attacker can crash memcached.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T20:55:00",
        "Published": "2021-09-29T20:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-35945",
        "impact": {},
        "last-modified": "2021-09-29T20:55:00",
        "references": [
            "https://www.couchbase.com/alerts",
            "https://docs.couchbase.com/server/current/release-notes/relnotes.html"
        ],
        "summary": "Couchbase Server 6.5.x, 6.6.0 through 6.6.2, and 7.0.0, has a Buffer Overflow. A specially crafted network packet sent from an attacker can crash memcached.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T20:55:00",
        "Published": "2021-09-29T20:15:00",
        "access": {},
        "assigner": "security@wordfence.com",
        "capec": [
            {
                "id": "383",
                "name": "Harvesting Information via API Event Monitoring",
                "prerequisites": "The target software is utilizing application framework APIs",
                "related_weakness": [
                    "311",
                    "319",
                    "419",
                    "602"
                ],
                "solutions": "Leverage encryption techniques during information transactions so as to protect them from attack patterns of this kind.",
                "summary": "An adversary hosts an event within an application framework and then monitors the data exchanged during the course of the event for the purpose of harvesting any important data leaked during the transactions. One example could be harvesting lists of usernames or userIDs for the purpose of sending spam messages to those users. One example of this type of attack involves the adversary creating an event within the sub-application. Assume the adversary hosts a \"virtual sale\" of rare items. As other users enter the event, the attacker records via MITM proxy the user_ids and usernames of everyone who attends. The adversary would then be able to spam those users within the application using an automated script."
            },
            {
                "id": "477",
                "name": "Signature Spoofing by Mixing Signed and Unsigned Content",
                "prerequisites": "Signer and recipient are using complex data storage structures that allow for a mix between signed and unsigned data Recipient is using signature verification software that does not maintain separation between signed and unsigned data once the signature has been verified.",
                "related_weakness": [
                    "311",
                    "319",
                    "693"
                ],
                "solutions": "Ensure the application is fully patched and does not allow the processing of unsigned data as if it is signed data.",
                "summary": "An attacker exploits the underlying complexity of a data structure that allows for both signed and unsigned content, to cause unsigned data to be processed as though it were signed data."
            },
            {
                "id": "65",
                "name": "Sniff Application Code",
                "prerequisites": "The attacker must have the ability to place himself in the communication path between the client and server. The targeted application must receive some application code from the server; for example, dynamic updates, patches, applets or scripts. The attacker must be able to employ a sniffer on the network without being detected.",
                "related_weakness": [
                    "311",
                    "318",
                    "319",
                    "693",
                    "719"
                ],
                "solutions": "Design: Encrypt all communication between the client and server. Implementation: Use SSL, SSH, SCP. Operation: Use \"ifconfig/ipconfig\" or other tools to detect the sniffer installed in the network.",
                "summary": "An adversary passively sniffs network communications and captures application code bound for an authorized client. Once obtained, they can use it as-is, or through reverse-engineering glean sensitive information or exploit the trust relationship between the client and server. Such code may belong to a dynamic update to the client, a patch being applied to a client component or any such interaction where the client is authorized to communicate with the server."
            },
            {
                "id": "102",
                "name": "Session Sidejacking",
                "prerequisites": "An attacker and the victim are both using the same WiFi network. The victim has an active session with a target system. The victim is not using a secure channel to communicate with the target system (e.g. SSL, VPN, etc.) The victim initiated communication with a target system that requires transfer of the session token or the target application uses AJAX and thereby periodically \"rings home\" asynchronously using the session token",
                "related_weakness": [
                    "294",
                    "319",
                    "522",
                    "523",
                    "614"
                ],
                "solutions": "Make sure that HTTPS is used to communicate with the target system. Alternatively, use VPN if possible. It is important to ensure that all communication between the client and the server happens via an encrypted secure channel. Modify the session token with each transmission and protect it with cryptography. Add the idea of request sequencing that gives the server an ability to detect replay attacks.",
                "summary": "Session sidejacking takes advantage of an unencrypted communication channel between a victim and target system. The attacker sniffs traffic on a network looking for session tokens in unencrypted traffic. Once a session token is captured, the attacker performs malicious actions by using the stolen token with the targeted application to impersonate the victim. This attack is a specific method of session hijacking, which is exploiting a valid session token to gain unauthorized access to a target system or information. Other methods to perform a session hijacking are session fixation, cross-site scripting, or compromising a user or server machine and stealing the session token."
            },
            {
                "id": "117",
                "name": "Interception",
                "prerequisites": "The target must transmit data over a medium that is accessible to the adversary.",
                "related_weakness": [
                    "319"
                ],
                "solutions": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.",
                "summary": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content. However, this attack differs from a Man-In-the-Middle (MITM) attack, as the adversary does not alter the content of the communications nor forward data to the intended recipient."
            }
        ],
        "cvss": null,
        "cwe": "CWE-319",
        "id": "CVE-2021-39342",
        "impact": {},
        "last-modified": "2021-09-29T20:55:00",
        "references": [
            "https://plugins.trac.wordpress.org/changeset/2606811/credova-financial/trunk/credova-financial.php",
            "https://www.wordfence.com/vulnerability-advisories/#CVE-2021-39342"
        ],
        "summary": "The Credova_Financial WordPress plugin discloses a site's associated Credova API account username and password in plaintext via an AJAX action whenever a site user goes to checkout on a page that has the Credova Financing option enabled. This affects versions up to, and including, 1.4.8.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T20:55:00",
        "Published": "2021-09-29T20:15:00",
        "access": {},
        "assigner": "secalert@redhat.com",
        "capec": [],
        "cvss": null,
        "cwe": "CWE-862",
        "id": "CVE-2021-3653",
        "impact": {},
        "last-modified": "2021-09-29T20:55:00",
        "references": [
            "https://www.openwall.com/lists/oss-security/2021/08/16/1",
            "https://bugzilla.redhat.com/show_bug.cgi?id=1983686"
        ],
        "summary": "A flaw was found in the KVM's AMD code for supporting SVM nested virtualization. The flaw occurs when processing the VMCB (virtual machine control block) provided by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation of the \"int_ctl\" field, this issue could allow a malicious L1 to enable AVIC support (Advanced Virtual Interrupt Controller) for the L2 guest. As a result, the L2 guest would be allowed to read/write physical pages of the host, resulting in a crash of the entire system, leak of sensitive data or potential guest-to-host escape. This flaw affects Linux kernel versions prior to 5.14-rc7.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T20:55:00",
        "Published": "2021-09-29T20:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-41764",
        "impact": {},
        "last-modified": "2021-09-29T20:55:00",
        "references": [
            "https://gist.github.com/omriinbar/3c741d309e5d0ede29dc7ecdad4eba3f",
            "https://gist.github.com/omriinbar/8277193731d0edf20ef71299f304ab93",
            "https://github.com/streamaserver/streama"
        ],
        "summary": "A cross-site request forgery (CSRF) vulnerability exists in Streama up to and including v1.10.3. The application does not have CSRF checks in place when performing actions such as uploading local files. As a result, attackers could make a logged-in administrator upload arbitrary local files via a CSRF attack and send them to the attacker.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T20:55:00",
        "Published": "2021-09-29T18:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-41573",
        "impact": {},
        "last-modified": "2021-09-29T20:55:00",
        "references": [
            "https://www.hitachi.com/hirt/security/index.html",
            "https://www.hitachi.com/hirt/hitachi-sec/2021/602.html"
        ],
        "summary": "Hitachi Content Platform Anywhere (HCP-AW) 4.4.5 and later allows information disclosure. If authenticated user creates a link to a file or folder while the system was running version 4.3.x or earlier and then shares the link and then later deletes the file or folder without deleting the link and before the link expires. If the system has been upgraded to version 4.4.5 or 4.5.0 a malicious user with the link could browse and download all files of the authenticated user that created the link .",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T20:55:00",
        "Published": "2021-09-29T19:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-41732",
        "impact": {},
        "last-modified": "2021-09-29T20:55:00",
        "references": [
            "https://github.com/zeek/zeek/issues/1798"
        ],
        "summary": "An issue was discovered in zeek version 4.1.0. There is a HTTP request splitting vulnerability that will invalidate any ZEEK HTTP based security analysis.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T20:55:00",
        "Published": "2021-09-29T17:15:00",
        "access": {},
        "assigner": "report@snyk.io",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-23446",
        "impact": {},
        "last-modified": "2021-09-29T20:55:00",
        "references": [
            "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSBOWERGITHUBHANDSONTABLE-1726794",
            "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARS-1726795",
            "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSBOWER-1726796",
            "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-1726797",
            "https://snyk.io/vuln/SNYK-JS-HANDSONTABLE-1726770",
            "https://github.com/handsontable/handsontable/issues/8752",
            "https://snyk.io/vuln/SNYK-DOTNET-HANDSONTABLE-1726793",
            "https://github.com/handsontable/handsontable/pull/8742"
        ],
        "summary": "The package handsontable before 10.0.0; the package handsontable from 0 and before 10.0.0 are vulnerable to Regular Expression Denial of Service (ReDoS) in Handsontable.helper.isNumeric function.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T20:55:00",
        "Published": "2021-09-18T16:15:00",
        "access": {
            "authentication": "NONE",
            "complexity": "LOW",
            "vector": "NETWORK"
        },
        "assigner": "cve@mitre.org",
        "capec": [
            {
                "id": "94",
                "name": "Man in the Middle Attack",
                "prerequisites": "There are two components communicating with each other. An attacker is able to identify the nature and mechanism of communication between the two target components. An attacker can eavesdrop on the communication between the target components. Strong mutual authentication is not used between the two target components yielding opportunity for attacker interposition. The communication occurs in clear (not encrypted) or with insufficient and spoofable encryption.",
                "related_weakness": [
                    "287",
                    "290",
                    "294",
                    "300",
                    "593",
                    "724"
                ],
                "solutions": "Get your Public Key signed by a Certificate Authority Encrypt your communication using cryptography (SSL,...) Use Strong mutual authentication to always fully authenticate both ends of any communications channel. Exchange public keys using a secure channel",
                "summary": "This type of attack targets the communication between two components (typically client and server). The attacker places himself in the communication channel between the two components. Whenever one component attempts to communicate with the other (data flow, authentication challenges, etc.), the data first goes to the attacker, who has the opportunity to observe or alter it, and it is then passed on to the other component as if it was never observed. This interposition is transparent leaving the two compromised components unaware of the potential corruption or leakage of their communications. The potential for Man-in-the-Middle attacks yields an implicit lack of trust in communication or identify between two components. MITM attacks differ from sniffing attacks since they often modify the communications prior to delivering it to the intended recipient. These attacks also differ from interception attacks since they may forward the sender's original unmodified data, after copying it, instead of keeping it for themselves."
            },
            {
                "id": "57",
                "name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
                "prerequisites": "Opportunity to intercept must exist beyond the point where SSL is terminated. The attacker must be able to insert a listener actively (proxying the communication) or passively (sniffing the communication) in the client-server communication path.",
                "related_weakness": [
                    "287",
                    "300",
                    "693",
                    "724"
                ],
                "solutions": "Implementation: Implement message level security such as HMAC in the HTTP communication Design: Utilize defense in depth, do not rely on a single security mechanism like SSL Design: Enforce principle of least privilege",
                "summary": "This attack utilizes a REST(REpresentational State Transfer)-style applications' trust in the system resources and environment to obtain sensitive data once SSL is terminated. Rest applications premise is that they leverage existing infrastructure to deliver web services functionality. An example of this is a Rest application that uses HTTP Get methods and receives a HTTP response with an XML document. These Rest style web services are deployed on existing infrastructure such as Apache and IIS web servers with no SOAP stack required. Unfortunately from a security standpoint, there frequently is no interoperable identity security mechanism deployed, so Rest developers often fall back to SSL to deliver security. In large data centers, SSL is typically terminated at the edge of the network - at the firewall, load balancer, or router. Once the SSL is terminated the HTTP request is in the clear (unless developers have hashed or encrypted the values, but this is rare). The attacker can utilize a sniffer such as Wireshark to snapshot the credentials, such as username and password that are passed in the clear once SSL is terminated. Once the attacker gathers these credentials, they can submit requests to the web service provider just as authorized user do. There is not typically an authentication on the client side, beyond what is passed in the request itself so once this is compromised, then this is generally sufficient to compromise the service's authentication scheme."
            },
            {
                "id": "593",
                "name": "Session Hijacking",
                "prerequisites": "An application that leverages sessions to perform authentication.",
                "related_weakness": [
                    "287"
                ],
                "solutions": "Properly encrypt and sign identity tokens in transit, and use industry standard session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf. Utilize a session timeout for all sessions. If the user does not explicitly logout, terminate their session after this period of inactivity. If the user logs back in then a new session key should be generated.",
                "summary": "This type of attack involves an adversary that exploits weaknesses in an application's use of sessions in performing authentication. The advarsary is able to steal or manipulate an active session and use it to gain unathorized access to the application."
            },
            {
                "id": "194",
                "name": "Fake the Source of Data",
                "prerequisites": "This attack is only applicable when a vulnerable entity associates data or services with an identity. Without such an association, there would be no reason to fake the source.",
                "related_weakness": [
                    "287"
                ],
                "solutions": "",
                "summary": "An adversary takes advantage of improper authentication to provide data or services under a falsified identity. The purpose of using the falsified identity may be to prevent traceability of the provided data or to assume the rights granted to another individual. One of the simplest forms of this attack would be the creation of an email message with a modified \"From\" field in order to appear that the message was sent from someone other than the actual sender. The root of the attack (in this case the email system) fails to properly authenticate the source and this results in the reader incorrectly performing the instructed action. Results of the attack vary depending on the details of the attack, but common results include privilege escalation, obfuscation of other attacks, and data corruption/manipulation."
            },
            {
                "id": "114",
                "name": "Authentication Abuse",
                "prerequisites": "An authentication mechanism or subsystem implementing some form of authentication such as passwords, digest authentication, security certificates, etc. which is flawed in some way.",
                "related_weakness": [
                    "287"
                ],
                "solutions": "",
                "summary": "An attacker obtains unauthorized access to an application, service or device either through knowledge of the inherent weaknesses of an authentication mechanism, or by exploiting a flaw in the authentication scheme's implementation. In such an attack an authentication mechanism is functioning but a carefully controlled sequence of events causes the mechanism to grant access to the attacker. This attack may exploit assumptions made by the target's authentication procedures, such as assumptions regarding trust relationships or assumptions regarding the generation of secret values. This attack differs from Authentication Bypass attacks in that Authentication Abuse allows the attacker to be certified as a valid user through illegitimate means, while Authentication Bypass allows the user to access protected material without ever being certified as an authenticated user. This attack does not rely on prior sessions established by successfully authenticating users, as relied upon for the \"Exploitation of Session Variables, Resource IDs and other Trusted Credentials\" attack patterns."
            },
            {
                "id": "151",
                "name": "Identity Spoofing",
                "prerequisites": "The identity associated with the message or resource must be removable or modifiable in an undetectable way.",
                "related_weakness": [
                    "287"
                ],
                "solutions": "Employ robust authentication processes (e.g., multi-factor authentication).",
                "summary": "Identity Spoofing refers to the action of assuming (i.e., taking on) the identity of some other entity (human or non-human) and then using that identity to accomplish a goal. An adversary may craft messages that appear to come from a different principle or use stolen / spoofed authentication credentials. Alternatively, an adversary may intercept a message from a legitimate sender and attempt to make it look like the message comes from them without changing its content. The latter form of this attack can be used to hijack credentials from legitimate users. Identity Spoofing attacks need not be limited to transmitted messages - any resource that is associated with an identity (for example, a file with a signature) can be the target of an attack where the adversary attempts to change the apparent identity. This attack differs from Content Spoofing attacks where the adversary does not wish to change the apparent identity of the message but instead wishes to change what the message says. In an Identity Spoofing attack, the adversary is attempting to change the identity of the content."
            },
            {
                "id": "633",
                "name": "Token Impersonation",
                "prerequisites": "This pattern of attack is only applicable when a downstream user leverages tokens to verify identity, and then takes action based on that identity.",
                "related_weakness": [
                    "287"
                ],
                "solutions": "",
                "summary": "An adversary exploits a weakness in authentication to create an access token (or equivalent) that impersonates a different entity, and then associates a process/thread to that that impersonated token. This action causes a downstream user to make a decision or take action that is based on the assumed identity, and not the response that blocks the adversary."
            },
            {
                "id": "115",
                "name": "Authentication Bypass",
                "prerequisites": "An authentication mechanism or subsystem implementing some form of authentication such as passwords, digest authentication, security certificates, etc.",
                "related_weakness": [
                    "287"
                ],
                "solutions": "",
                "summary": "An attacker gains access to application, service, or device with the privileges of an authorized or privileged user by evading or circumventing an authentication mechanism. The attacker is therefore able to access protected data without authentication ever having taken place. This refers to an attacker gaining access equivalent to an authenticated user without ever going through an authentication procedure. This is usually the result of the attacker using an unexpected access procedure that does not go through the proper checkpoints where authentication should occur. For example, a web site might assume that all users will click through a given link in order to get to secure material and simply authenticate everyone that clicks the link. However, an attacker might be able to reach secured web content by explicitly entering the path to the content rather than clicking through the authentication link, thereby avoiding the check entirely. This attack pattern differs from other authentication attacks in that attacks of this pattern avoid authentication entirely, rather than faking authentication by exploiting flaws or by stealing credentials from legitimate users."
            },
            {
                "id": "22",
                "name": "Exploiting Trust in Client",
                "prerequisites": "Server software must rely on client side formatted and validated values, and not reinforce these checks on the server side.",
                "related_weakness": [
                    "20",
                    "200",
                    "287",
                    "290",
                    "693"
                ],
                "solutions": "Design: Ensure that client process and/or message is authenticated so that anonymous communications and/or messages are not accepted by the system. Design: Do not rely on client validation or encoding for security purposes. Design: Utilize digital signatures to increase authentication assurance. Design: Utilize two factor authentication to increase authentication assurance. Implementation: Perform input validation for all remote content.",
                "summary": "An attack of this type exploits vulnerabilities in client/server communication channel authentication and data integrity. It leverages the implicit trust a server places in the client, or more importantly, that which the server believes is the client. An attacker executes this type of attack by communicating directly with the server where the server believes it is communicating only with a valid client. There are numerous variations of this type of attack."
            },
            {
                "id": "650",
                "name": "Upload a Web Shell to a Web Server",
                "prerequisites": "The web server is susceptible to one of the various web application exploits that allows for uploading a shell file.",
                "related_weakness": [
                    "287",
                    "553"
                ],
                "solutions": "Insure that the file permissions in directories on the web server from which files can be execute is set to the \"least privilege\" settings, and that those directories contents is controlled by a whitelist.",
                "summary": "By exploiting insufficient permissions, it is possible to upload a web shell to a web server in such a way that it can be executed remotely. This shell can have various capabilities, thereby acting as a \"gateway\" to the underlying web server. The shell might execute at the higher permission level of the web server, providing the ability the execute malicious code at elevated levels."
            }
        ],
        "cvss": 7.5,
        "cvss-time": "2021-09-29T20:55:00",
        "cvss-vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
        "cwe": "CWE-287",
        "id": "CVE-2021-41393",
        "impact": {
            "availability": "PARTIAL",
            "confidentiality": "PARTIAL",
            "integrity": "PARTIAL"
        },
        "last-modified": "2021-09-29T20:55:00",
        "references": [
            "https://github.com/gravitational/teleport/releases/tag/v6.2.12",
            "https://github.com/gravitational/teleport/releases/tag/v4.4.11",
            "https://github.com/gravitational/teleport/releases/tag/v5.2.4",
            "https://github.com/gravitational/teleport/releases/tag/v7.1.1"
        ],
        "summary": "Teleport before 4.4.11, 5.x before 5.2.4, 6.x before 6.2.12, and 7.x before 7.1.1 allows forgery of SSH host certificates in some situations.",
        "vulnerable_configuration": [],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": []
    },
    {
        "Modified": "2021-09-29T20:54:00",
        "Published": "2021-09-23T20:15:00",
        "access": {
            "authentication": "SINGLE",
            "complexity": "MEDIUM",
            "vector": "NETWORK"
        },
        "assigner": "cve@mitre.org",
        "capec": [
            {
                "id": "591",
                "name": "Reflected XSS",
                "prerequisites": "An application that leverages a client-side web browser with scripting enabled. An application that fail to adequately sanitize or encode untrusted input.",
                "related_weakness": [
                    "79"
                ],
                "solutions": "Use browser technologies that do not allow client-side scripting. Utilize strict type, character, and encoding enforcement. Ensure that all user-supplied input is validated before use.",
                "summary": "This type of attack is a form of Cross-Site Scripting (XSS) where a malicious script is \"reflected\" off a vulnerable web application and then executed by a victim's browser. The process starts with an adversary delivering a malicious script to a victim and convincing the victim to send the script to the vulnerable web application. The most common method of this is through a phishing email where the adversary embeds the malicious script with a URL that the victim then clicks on. In processing the subsequent request, the vulnerable web application incorrectly considers the malicious script as valid input and uses it to creates a reposnse that is then sent back to the victim. To launch a successful Reflected XSS attack, an adversary looks for places where user-input is used directly in the generation of a response. This often involves elements that are not expected to host scripts such as image tags (<img>), or the addition of event attibutes such as onload and onmouseover. These elements are often not subject to the same input validation, output encoding, and other content filtering and checking routines."
            },
            {
                "id": "209",
                "name": "XSS Using MIME Type Mismatch",
                "prerequisites": "The victim must follow a crafted link that references a scripting file that is mis-typed as a non-executable file. The victim's browser must detect the true type of a mis-labeled scripting file and invoke the appropriate script interpreter without first performing filtering on the content.",
                "related_weakness": [
                    "20",
                    "646",
                    "79"
                ],
                "solutions": "",
                "summary": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser."
            },
            {
                "id": "588",
                "name": "DOM-Based XSS",
                "prerequisites": "An application that leverages a client-side web browser with scripting enabled. An application that manipulates the DOM via client-side scripting. An application that failS to adequately sanitize or encode untrusted input.",
                "related_weakness": [
                    "20",
                    "79",
                    "83"
                ],
                "solutions": "Use browser technologies that do not allow client-side scripting. Utilize proper character encoding for all output produced within client-site scripts manipulating the DOM. Ensure that all user-supplied input is validated before use.",
                "summary": "This type of attack is a form of Cross-Site Scripting (XSS) where a malicious script is inserted into the client-side HTML being parsed by a web browser. Content served by a vulnerable web application includes script code used to manipulate the Document Object Model (DOM). This script code either does not properly validate input, or does not perform proper output encoding, thus creating an opportunity for an adversary to inject a malicious script launch a XSS attack. A key distinction between other XSS attacks and DOM-based attacks is that in other XSS attacks, the malicious script runs when the vulnerable web page is initially loaded, while a DOM-based attack executes sometime after the page loads. Another distinction of DOM-based attacks is that in some cases, the malicious script is never sent to the vulnerable web server at all. An attack like this is guaranteed to bypass any server-side filtering attempts to protect users."
            },
            {
                "id": "592",
                "name": "Stored XSS",
                "prerequisites": "An application that leverages a client-side web browser with scripting enabled. An application that fails to adequately sanitize or encode untrusted input. An application that stores information provided by the user in data storage of some kind.",
                "related_weakness": [
                    "79"
                ],
                "solutions": "Use browser technologies that do not allow client-side scripting. Utilize strict type, character, and encoding enforcement. Ensure that all user-supplied input is validated before being stored.",
                "summary": "This type of attack is a form of Cross-site Scripting (XSS) where a malicious script is persistenly \"stored\" within the data storage of a vulnerable web application. Initially presented by an adversary to the vulnerable web application, the malicious script is incorrectly considered valid input and is not properly encoded by the web application. A victim is then convinced to use the web application in a way that creates a response that includes the malicious script. This response is subsequently sent to the victim and the malicious script is executed by the victim's browser. To launch a successful Stored XSS attack, an adversary looks for places where stored input data is used in the generation of a response. This often involves elements that are not expected to host scripts such as image tags (<img>), or the addition of event attibutes such as onload and onmouseover. These elements are often not subject to the same input validation, output encoding, and other content filtering and checking routines."
            },
            {
                "id": "85",
                "name": "AJAX Fingerprinting",
                "prerequisites": "The user must allow JavaScript to execute in their browser",
                "related_weakness": [
                    "113",
                    "116",
                    "184",
                    "20",
                    "348",
                    "692",
                    "712",
                    "79",
                    "86",
                    "96"
                ],
                "solutions": "Design: Use browser technologies that do not allow client side scripting. Design: Utilize strict type, character, and encoding enforcement Implementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification. Implementation: Perform input validation for all remote content. Implementation: Perform output validation for all remote content. Implementation: Disable scripting languages such as JavaScript in browser Implementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.",
                "summary": "This attack utilizes the frequent client-server roundtrips in Ajax conversation to scan a system. While Ajax does not open up new vulnerabilities per se, it does optimize them from an attacker point of view. In many XSS attacks the attacker must get a \"hole in one\" and successfully exploit the vulnerability on the victim side the first time, once the client is redirected the attacker has many chances to engage in follow on probes, but there is only one first chance. In a widely used web application this is not a major problem because 1 in a 1,000 is good enough in a widely used application. A common first step for an attacker is to footprint the environment to understand what attacks will work. Since footprinting relies on enumeration, the conversational pattern of rapid, multiple requests and responses that are typical in Ajax applications enable an attacker to look for many vulnerabilities, well-known ports, network locations and so on."
            },
            {
                "id": "63",
                "name": "Cross-Site Scripting (XSS)",
                "prerequisites": "Target client software must be a client that allows scripting communication from remote hosts, such as a JavaScript-enabled Web Browser.",
                "related_weakness": [
                    "20",
                    "79"
                ],
                "solutions": "Design: Use browser technologies that do not allow client side scripting. Design: Utilize strict type, character, and encoding enforcement Design: Server side developers should not proxy content via XHR or other means, if a http proxy for remote content is setup on the server side, the client's browser has no way of discerning where the data is originating from. Implementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification. Implementation: Perform input validation for all remote content. Implementation: Perform output validation for all remote content. Implementation: Session tokens for specific host Implementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.",
                "summary": "An adversary embeds malicious scripts in content that will be served to web browsers. The goal of the attack is for the target software, the client-side browser, to execute the script with the users' privilege level. An attack of this type exploits a programs' vulnerabilities that are brought on by allowing remote hosts to execute code and scripts. Web browsers, for example, have some simple security controls in place, but if a remote attacker is allowed to execute scripts (through injecting them in to user-generated content like bulletin boards) then these controls may be bypassed. Further, these attacks are very difficult for an end user to detect."
            }
        ],
        "cvss": 3.5,
        "cvss-time": "2021-09-29T20:54:00",
        "cvss-vector": "AV:N/AC:M/Au:S/C:N/I:P/A:N",
        "cwe": "CWE-79",
        "id": "CVE-2020-19950",
        "impact": {
            "availability": "NONE",
            "confidentiality": "NONE",
            "integrity": "PARTIAL"
        },
        "last-modified": "2021-09-29T20:54:00",
        "references": [
            "https://github.com/yzmcms/yzmcms/issues/22"
        ],
        "summary": "A cross-site scripting (XSS) vulnerability in the /banner/add.html component of YzmCMS v5.3 allows attackers to execute arbitrary web scripts or HTML.",
        "vulnerable_configuration": [
            "cpe:2.3:a:yzmcms:yzmcms:5.3:*:*:*:*:*:*:*"
        ],
        "vulnerable_configuration_cpe_2_2": [],
        "vulnerable_product": [
            "cpe:2.3:a:yzmcms:yzmcms:5.3:*:*:*:*:*:*:*"
        ]
    }
]